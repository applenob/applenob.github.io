<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"applenob.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1《剑指offer》第二版python版总结。  动机个人觉得在准备找工作要刷题前，先刷一遍这本书的问题，再去刷LeetCode这类的OJ比较合适。难度循序渐进，亦有理论支撑。 阅读流程：按照目录去索引问题，找到问题后，先看问题描述，思考问题解决思路；然后看思路，获取提示；然后阅读优点和复杂度，检查和自己想的是否一致。 用到的数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指offer》所有习题python解法">
<meta property="og:url" content="https://applenob.github.io/algrithom/pt_offer_summary_py/index.html">
<meta property="og:site_name" content="Javen Chen&#39;s Blog">
<meta property="og:description" content="1《剑指offer》第二版python版总结。  动机个人觉得在准备找工作要刷题前，先刷一遍这本书的问题，再去刷LeetCode这类的OJ比较合适。难度循序渐进，亦有理论支撑。 阅读流程：按照目录去索引问题，找到问题后，先看问题描述，思考问题解决思路；然后看思路，获取提示；然后阅读优点和复杂度，检查和自己想的是否一致。 用到的数据结构">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-03-27T19:40:00.000Z">
<meta property="article:modified_time" content="2024-11-10T20:30:54.028Z">
<meta property="article:author" content="Javen Chen">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://applenob.github.io/algrithom/pt_offer_summary_py/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://applenob.github.io/algrithom/pt_offer_summary_py/","path":"algrithom/pt_offer_summary_py/","title":"《剑指offer》所有习题python解法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《剑指offer》所有习题python解法 | Javen Chen's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Javen Chen's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Tech and Life~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">用到的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">3.</span> <span class="nav-text">NO.3 数组中重复的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">4.</span> <span class="nav-text">NO.4 二维数组的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">NO.6 从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">NO.7 重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">7.</span> <span class="nav-text">NO.8 二叉树的下一个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text">NO.9 用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-10-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">9.</span> <span class="nav-text">NO.10 斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">9.1.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">NO.11 旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">10.1.</span> <span class="nav-text">回溯</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">11.</span> <span class="nav-text">NO.12 矩阵中的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">12.</span> <span class="nav-text">NO.13 机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">12.1.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95"><span class="nav-number">12.2.</span> <span class="nav-text">贪婪算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-14-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">13.</span> <span class="nav-text">NO.14 剪绳子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E8%A7%A3%E6%B3%95"><span class="nav-number">13.1.</span> <span class="nav-text">贪婪算法解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">NO.15 二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">15.</span> <span class="nav-text">NO.16 数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-17-%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="nav-number">16.</span> <span class="nav-text">NO.17 打印1到最大的n位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-18-%E5%9C%A8O%EF%BC%881%EF%BC%89%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9"><span class="nav-number">17.</span> <span class="nav-text">NO.18 在O（1）时间删除链表结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">18.</span> <span class="nav-text">NO.19 正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">19.</span> <span class="nav-text">NO.20 表示数值的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-number">20.</span> <span class="nav-text">NO.21 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">21.</span> <span class="nav-text">NO.22 链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="nav-number">22.</span> <span class="nav-text">NO.23 链表中环的入口节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">23.</span> <span class="nav-text">NO.24 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">24.</span> <span class="nav-text">NO.25 合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">25.</span> <span class="nav-text">NO.26 树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">26.</span> <span class="nav-text">NO.27 二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">27.</span> <span class="nav-text">NO.28 对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">28.</span> <span class="nav-text">NO.29 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">29.</span> <span class="nav-text">NO.30 包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">30.</span> <span class="nav-text">NO.31 栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">31.</span> <span class="nav-text">NO.32 从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">32.</span> <span class="nav-text">NO.33 二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">33.</span> <span class="nav-text">NO.34 二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">34.</span> <span class="nav-text">NO.35 复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">35.</span> <span class="nav-text">NO.36 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">36.</span> <span class="nav-text">NO.37 序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">37.</span> <span class="nav-text">NO.38 字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">38.</span> <span class="nav-text">NO.39 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="nav-number">39.</span> <span class="nav-text">NO.40 最小的k个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">40.</span> <span class="nav-text">NO.41 数据流中的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">41.</span> <span class="nav-text">NO.42 连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-43-%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">42.</span> <span class="nav-text">NO.43 从1到n整数中1出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">43.</span> <span class="nav-text">NO.44 数字序列中某一位的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">44.</span> <span class="nav-text">NO.45 把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">45.</span> <span class="nav-text">NO.46 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">46.</span> <span class="nav-text">NO.47 礼物的最大价值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">47.</span> <span class="nav-text">NO.48 最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-49-%E4%B8%91%E6%95%B0"><span class="nav-number">48.</span> <span class="nav-text">NO.49 丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">49.</span> <span class="nav-text">NO.50 第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">50.</span> <span class="nav-text">NO.51 数组中的逆序对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">51.</span> <span class="nav-text">NO.52 两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-53-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97"><span class="nav-number">52.</span> <span class="nav-text">NO.53 在排序数组中查找数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">53.</span> <span class="nav-text">NO.54 二叉搜索树的第k大节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-55-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">54.</span> <span class="nav-text">NO.55 二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">54.1.</span> <span class="nav-text">相关：平衡二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-56-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">55.</span> <span class="nav-text">NO.56 数组中数字出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">56.</span> <span class="nav-text">NO.57 和为s的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-58-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">57.</span> <span class="nav-text">NO.58 翻转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-59-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">58.</span> <span class="nav-text">NO.59 队列的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-number">59.</span> <span class="nav-text">NO.60 n个骰子的点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-number">60.</span> <span class="nav-text">NO.61 扑克牌中的顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">61.</span> <span class="nav-text">NO.62 圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="nav-number">62.</span> <span class="nav-text">NO.63 股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-64-%E6%B1%821-2-%E2%80%A6-n"><span class="nav-number">63.</span> <span class="nav-text">NO.64 求1+2+…+n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">64.</span> <span class="nav-text">NO.65 不用加减乘除做加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="nav-number">65.</span> <span class="nav-text">NO.66 构建乘积数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="nav-number">66.</span> <span class="nav-text">NO.67 把字符串转换成整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NO-68-%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">67.</span> <span class="nav-text">NO.68 树中两个结点的最低公共祖先</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Javen Chen"
      src="/images/ggb.png">
  <p class="site-author-name" itemprop="name">Javen Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/applenob" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;applenob" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:applenobcer@gmail.com" title="E-Mail → mailto:applenobcer@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://applenob.github.io/algrithom/pt_offer_summary_py/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ggb.png">
      <meta itemprop="name" content="Javen Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Javen Chen's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《剑指offer》所有习题python解法 | Javen Chen's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《剑指offer》所有习题python解法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-03-27 12:40:00" itemprop="dateCreated datePublished" datetime="2017-03-27T12:40:00-07:00">2017-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-11-10 12:30:54" itemprop="dateModified" datetime="2024-11-10T12:30:54-08:00">2024-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">算法题解</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">《剑指offer》第二版python版总结。</span><br></pre></td></tr></table></figure>

<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>个人觉得在准备找工作要刷题前，先刷一遍这本书的问题，再去刷LeetCode这类的OJ比较合适。难度循序渐进，亦有理论支撑。</p>
<p>阅读流程：按照目录去索引问题，找到问题后，先看<strong>问题描述</strong>，思考问题解决思路；然后看<strong>思路</strong>，获取提示；然后阅读<strong>优点</strong>和<strong>复杂度</strong>，检查和自己想的是否一致。</p>
<h2 id="用到的数据结构"><a href="#用到的数据结构" class="headerlink" title="用到的数据结构"></a>用到的数据结构</h2><p>数据结构定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Self-defined data structures and some tool functions.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;List node.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = x</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Tree node.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = x</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomListNode</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;List node with a random field.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = x</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeLinkNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = x</span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">head_node</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Traverse a list and print.&quot;&quot;&quot;</span></span><br><span class="line">    vals = []</span><br><span class="line">    <span class="keyword">while</span> head_node:</span><br><span class="line">        vals.append(head_node.val)</span><br><span class="line">        head_node = head_node.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vals) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, vals)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This node list is empty!&quot;</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_random_list</span>(<span class="params">head_node</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Traverse a random list and print.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> head_node:</span><br><span class="line">        <span class="keyword">if</span> head_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            val_of_next = head_node.<span class="built_in">next</span>.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            val_of_next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> head_node.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            val_of_random = head_node.random.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            val_of_random = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;val: &#123;&#125;, val of next: &#123;&#125;, val of random: &#123;&#125; &quot;</span>.<span class="built_in">format</span>(head_node.val, val_of_next, val_of_random))</span><br><span class="line">        head_node = head_node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_tree</span>(<span class="params">root_node</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Travers a tree by level and print.&quot;&quot;&quot;</span></span><br><span class="line">    travers = []</span><br><span class="line">    queue = [root_node]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        farther = queue.pop()</span><br><span class="line">        travers.append(farther.val)</span><br><span class="line">        <span class="keyword">if</span> farther:</span><br><span class="line">            <span class="keyword">if</span> farther.left:</span><br><span class="line">                queue.insert(<span class="number">0</span>, farther.left)</span><br><span class="line">            <span class="keyword">if</span> farther.right:</span><br><span class="line">                queue.insert(<span class="number">0</span>, farther.right)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, travers)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_nodes_by_list</span>(<span class="params">l</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Initialize a List nodes with a given list of values.&quot;&quot;&quot;</span></span><br><span class="line">    head = last_node = ListNode(l[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> l[<span class="number">1</span>:]:</span><br><span class="line">        node = ListNode(one)</span><br><span class="line">        last_node.<span class="built_in">next</span> = node</span><br><span class="line">        last_node = node</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h2 id="NO-3-数组中重复的数字"><a href="#NO-3-数组中重复的数字" class="headerlink" title="NO.3 数组中重复的数字"></a>NO.3 数组中重复的数字</h2><ul>
<li><strong>问题描述</strong>：在一个长度是n的数组里的所有数字都在0～n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3.</li>
<li><strong>思路</strong>：如果先排序，则时间复杂度是$O(logn)$。注意到数字的范围，所以如果将每个检查到的数，换到以这个数为下标的位置，则数组不会溢出。而且在交换的过程中，可以很快地检查是否有重复。</li>
<li><strong>优点</strong>：时间复杂度低。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isDuplicate</span>(<span class="params">nums</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">        cur_val = nums[i]</span><br><span class="line">        <span class="comment"># 当前值和不在这个值对应的下标上</span></span><br><span class="line">        <span class="keyword">while</span> cur_val != i:</span><br><span class="line">            <span class="comment"># 如果这个值对应的下标上已经是这个值，说明重复</span></span><br><span class="line">            <span class="keyword">if</span> nums[cur_val] == cur_val:</span><br><span class="line">                <span class="keyword">return</span> cur_val</span><br><span class="line">            <span class="comment"># 否则将当前值交换到这个值对应的下标上</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># swap in a pythonic way</span></span><br><span class="line">                nums[cur_val], nums[i] = nums[i], nums[cur_val]</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">isDuplicate(test_nums)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="NO-4-二维数组的查找"><a href="#NO-4-二维数组的查找" class="headerlink" title="NO.4 二维数组的查找"></a>NO.4 二维数组的查找</h2><ul>
<li><strong>问题描述</strong>：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</li>
<li><strong>思路</strong>：从右上角开始判断，若小于则在左边，大于则在下面。直到找完。</li>
<li><strong>优点</strong>：区域不会重合</li>
<li><strong>时间复杂度</strong>：$O(m+n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Find</span>(<span class="params">target, array</span>):</span><br><span class="line">    <span class="comment"># 2-d array size: m * n</span></span><br><span class="line">    m = <span class="built_in">len</span>(array)</span><br><span class="line">    n = <span class="built_in">len</span>(array[<span class="number">0</span>])</span><br><span class="line">    j = n-<span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> array[i][j] &lt; target:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Find(<span class="number">7</span>, [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>], [<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>]])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="NO-6-从尾到头打印链表"><a href="#NO-6-从尾到头打印链表" class="headerlink" title="NO.6 从尾到头打印链表"></a>NO.6 从尾到头打印链表</h2><ul>
<li><strong>问题描述</strong>：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。</li>
<li><strong>思路</strong>：使用一个栈，保存正序遍历的值。</li>
<li><strong>空间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printListFromTailToHead</span>(<span class="params">listNode</span>):</span><br><span class="line">    values = []</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">while</span> listNode != <span class="literal">None</span>:</span><br><span class="line">        stack.append(listNode.val)</span><br><span class="line">        listNode = listNode.<span class="built_in">next</span></span><br><span class="line"><span class="comment">#     values = stack[::-1]</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(stack)):</span><br><span class="line">        values.append(stack.pop())</span><br><span class="line">    <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">l2 = ListNode(<span class="number">2</span>)</span><br><span class="line">l3 = ListNode(<span class="number">3</span>)</span><br><span class="line">l1.<span class="built_in">next</span> = l2</span><br><span class="line">l2.<span class="built_in">next</span> = l3</span><br><span class="line"><span class="built_in">print</span>(printListFromTailToHead(l1))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure>

<h2 id="NO-7-重建二叉树"><a href="#NO-7-重建二叉树" class="headerlink" title="NO.7 重建二叉树"></a>NO.7 重建二叉树</h2><ul>
<li><strong>问题描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出二叉树并输出它的头结点。</li>
<li><strong>思路</strong>：根据中序遍历和前序遍历可以很快找到（左子树，根，右子树）的分割，用递归实现。</li>
<li><strong>优点</strong>：思路简单清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reConstructBinaryTree</span>(<span class="params">preorder, inorder, length</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">return</span> constructCore(preorder, inorder, <span class="number">0</span>, length-<span class="number">1</span>, <span class="number">0</span>, length-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constructCore</span>(<span class="params">preorder, inorder, p_s, p_e, i_s, i_e</span>):</span><br><span class="line">    root_val = preorder[p_s]</span><br><span class="line">    root = TreeNode(root_val)</span><br><span class="line">    <span class="keyword">if</span> p_s == p_e <span class="keyword">or</span> i_s == i_e:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    root_ind = inorder.index(root_val)</span><br><span class="line">    left_len = root_ind - i_s </span><br><span class="line">    right_len = i_e - root_ind</span><br><span class="line">    <span class="keyword">if</span> left_len &gt; <span class="number">0</span>: </span><br><span class="line"><span class="comment">#         print &quot;left&quot;, p_s+1, p_s+left_len, i_s, root_ind-1</span></span><br><span class="line">        root.left = constructCore(preorder, inorder, p_s+<span class="number">1</span>, p_s+left_len, i_s, root_ind-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> right_len &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment">#         print &quot;right&quot;, p_s+left_len+1, p_e, root_ind+1, i_e</span></span><br><span class="line">        root.right = constructCore(preorder, inorder, p_s+left_len+<span class="number">1</span>, p_e, root_ind+<span class="number">1</span>, i_e)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">tin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">print_tree(reConstructBinaryTree(pre, tin, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure>

<h2 id="NO-8-二叉树的下一个节点"><a href="#NO-8-二叉树的下一个节点" class="headerlink" title="NO.8 二叉树的下一个节点"></a>NO.8 二叉树的下一个节点</h2><ul>
<li><strong>问题描述</strong>：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
</ul>
<h2 id="NO-9-用两个栈实现队列"><a href="#NO-9-用两个栈实现队列" class="headerlink" title="NO.9 用两个栈实现队列"></a>NO.9 用两个栈实现队列</h2><ul>
<li><strong>问题描述</strong>：用两个栈实现一个队列。请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</li>
<li><strong>思路</strong>：一个栈负责入队，另一个栈负责出队。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack1 = []</span><br><span class="line">        <span class="variable language_">self</span>.stack2 = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack1.append(val)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.stack1)):</span><br><span class="line">                <span class="variable language_">self</span>.stack2.append(<span class="variable language_">self</span>.stack1.pop())</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.stack2) == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Queue is empty!&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack2.pop()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cqueue = CQueue()</span><br><span class="line">cqueue.appendTail(<span class="number">1</span>)</span><br><span class="line">cqueue.appendTail(<span class="number">2</span>)</span><br><span class="line">cqueue.appendTail(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(cqueue.deleteHead())</span><br><span class="line"><span class="built_in">print</span>(cqueue.deleteHead())</span><br><span class="line"><span class="built_in">print</span>(cqueue.deleteHead())</span><br><span class="line"><span class="built_in">print</span>(cqueue.deleteHead())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Queue is empty!</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<h2 id="NO-10-斐波那契数列"><a href="#NO-10-斐波那契数列" class="headerlink" title="NO.10 斐波那契数列"></a>NO.10 斐波那契数列</h2><ul>
<li><strong>问题描述</strong>：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</li>
<li><strong>思路</strong>：不用递归，用保存数组的方式。</li>
<li><strong>优点</strong>：时间复杂度比递归小。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    minus_one = <span class="number">1</span></span><br><span class="line">    minus_two = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = minus_one + minus_two</span><br><span class="line">        minus_two = minus_one</span><br><span class="line">        minus_one = res</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>((i, Fibonacci(i)), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0, 0) (1, 0) (2, 1) (3, 2) (4, 3) (5, 5) (6, 8) (7, 13) (8, 21) (9, 34)</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排的整体思想就是每次执行一次partition，然后根据partition返回的位置将数组分成两段，再递归地对这两段子序列进行快排。</p>
<p><code>partition</code>: 将当前第一个元素作为pivot，小的元素往前移到pivot的前面，大的元素往后移到pivot的后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">data, l, s, e</span>):</span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    pivot_index = partition(data, l, s, e)</span><br><span class="line"><span class="comment">#     print(data)</span></span><br><span class="line">    <span class="keyword">if</span> pivot_index &gt; s:</span><br><span class="line">        quickSort(data, l, s, pivot_index - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> pivot_index &lt; e:</span><br><span class="line">        quickSort(data, l, pivot_index + <span class="number">1</span>, e)</span><br></pre></td></tr></table></figure>

<p>不同的快排实现差别主要在partition的实现上。下面是《Problem Solving with Algorithms and Data Structures》上的解法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def partition(data, l, s, e):</span></span><br><span class="line"><span class="comment">#     &quot;&quot;&quot;双指针互换&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#     pivot_index = s</span></span><br><span class="line"><span class="comment">#     pivot_value = data[pivot_index]</span></span><br><span class="line"><span class="comment">#     print(&quot;pivot_index: &quot;, pivot_index, &quot;pivot_value: &quot;, pivot_value)</span></span><br><span class="line"><span class="comment">#     if s == e:</span></span><br><span class="line"><span class="comment">#         return pivot_index</span></span><br><span class="line"><span class="comment">#     # 双指针法</span></span><br><span class="line"><span class="comment">#     p1 = s + 1</span></span><br><span class="line"><span class="comment">#     p2 = e</span></span><br><span class="line"><span class="comment">#     done = False</span></span><br><span class="line"><span class="comment">#     while not done:</span></span><br><span class="line"><span class="comment">#         # 找到左边一个大的（待换）</span></span><br><span class="line"><span class="comment">#         while data[p1] &lt;= pivot_value and p1 &lt;= p2:</span></span><br><span class="line"><span class="comment">#             p1 += 1</span></span><br><span class="line"><span class="comment">#         #　找到右边一个小的（待换）</span></span><br><span class="line"><span class="comment">#         while data[p2] &gt;= pivot_value and p1 &lt;= p2:</span></span><br><span class="line"><span class="comment">#             p2 -= 1</span></span><br><span class="line"><span class="comment">#         if p1 &gt; p2:</span></span><br><span class="line"><span class="comment">#             done = True</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             data[p2], data[p1] = data[p1], data[p2] </span></span><br><span class="line"><span class="comment">#     print(&quot;p1: &quot;, p1, &quot;p2: &quot;, p2)</span></span><br><span class="line"><span class="comment">#     data[p2], data[pivot_index] = data[pivot_index], data[p2]</span></span><br><span class="line"><span class="comment">#     return p2</span></span><br></pre></td></tr></table></figure>

<p>《剑指offer》的写法，倾向用这种。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">data, l, s, e</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;记录一个small指针和当前指针&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == e:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    small = s </span><br><span class="line">    pivot_index = s</span><br><span class="line">    pivot_value = data[pivot_index]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, e):</span><br><span class="line">        <span class="keyword">if</span> data[i] &lt; pivot_value:</span><br><span class="line">            small += <span class="number">1</span></span><br><span class="line">            data[i], data[small] = data[small], data[i]</span><br><span class="line">    data[small], data[s] = data[s], data[small]</span><br><span class="line">    <span class="keyword">return</span> small</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_data = [<span class="number">11</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">22</span>]</span><br><span class="line">quickSort(test_data, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(test_data)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 6, 4, 7, 8, 9, 11, 15, 22]</span><br></pre></td></tr></table></figure>

<h2 id="NO-11-旋转数组的最小数字"><a href="#NO-11-旋转数组的最小数字" class="headerlink" title="NO.11 旋转数组的最小数字"></a>NO.11 旋转数组的最小数字</h2><ul>
<li><strong>问题描述</strong>：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</li>
<li><strong>思路</strong>：注意到最小的元素刚好是这两个子数组的分界线，用二分查找法的思路来寻找这个最小的元素。提示：１．第一个元素应该是大于或者等于最后一个元素的。２．前面子序列的元素都大于或者等于后面的子序列的元素。</li>
<li><strong>优点</strong>：时间复杂度低。</li>
<li><strong>时间复杂度</strong>：$O(logn)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findRotateMin1</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用二分查找寻找最小值，初版&quot;&quot;&quot;</span></span><br><span class="line">    l = <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data is empty.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    e = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s &lt; e:</span><br><span class="line">        <span class="keyword">if</span> e - s == <span class="number">1</span>:</span><br><span class="line">            mid = e</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        mid = (s + e) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 中间元素比起始元素小，所以中间元素属于属于第二个子序列</span></span><br><span class="line">        <span class="keyword">if</span> data[mid] &lt; data[s]:</span><br><span class="line">            e = mid</span><br><span class="line">        <span class="comment"># 中间元素不比其实元素小，所以中间元素属于第一个子序列</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = mid</span><br><span class="line">    <span class="keyword">return</span> data[mid]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findRotateMin1([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>正确</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findRotateMin1([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minInOrder</span>(<span class="params">data, s, e</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;顺序查找&quot;&quot;&quot;</span></span><br><span class="line">    res = data[s]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s + <span class="number">1</span>, e + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> res &gt; data[i]:</span><br><span class="line">            res = data[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findRotateMin2</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用二分查找寻找最小值，完整版&quot;&quot;&quot;</span></span><br><span class="line">    l = <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data is empty.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    e = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s &lt; e:</span><br><span class="line">        <span class="keyword">if</span> e - s == <span class="number">1</span>:</span><br><span class="line">            mid = e</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        mid = (s + e) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 如果s、e、mid指向的元素都相等，只能顺序查找</span></span><br><span class="line">        <span class="keyword">if</span> data[mid] == data[s] <span class="keyword">and</span> data[mid] == data[e]:</span><br><span class="line">            <span class="keyword">return</span> minInOrder(data, s, e)</span><br><span class="line">        <span class="comment"># 中间元素比起始元素小，所以中间元素属于属于第二个子序列</span></span><br><span class="line">        <span class="keyword">if</span> data[mid] &lt; data[s]:</span><br><span class="line">            e = mid</span><br><span class="line">        <span class="comment"># 中间元素不比其实元素小，所以中间元素属于第一个子序列</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = mid</span><br><span class="line">    <span class="keyword">return</span> data[mid]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findRotateMin2([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findRotateMin2([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p>都正确。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯法可以看成是蛮力法的升级版，它从解决问题每一步的所有可能选项里面系统地选择出一个可行的解决方案。回溯法非常适合由<strong>多个步骤</strong>组成，并且每个步骤都有多个选项。</p>
<p>下面两道题涉及回溯的思想，在解决回溯类的问题时，脑海中要想象一棵<strong>搜索树</strong>，树的每一层对应着一个步骤的搜索空间，如果在某层搜索失败，则需要<strong>回溯</strong>到上一步骤。</p>
<h2 id="NO-12-矩阵中的路径"><a href="#NO-12-矩阵中的路径" class="headerlink" title="NO.12 矩阵中的路径"></a>NO.12 矩阵中的路径</h2><ul>
<li><strong>问题描述</strong>：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如<code>[[&quot;a&quot;, &quot;b&quot;, &quot;t&quot;, &quot;g&quot;], [&quot;c&quot;, &quot;f&quot;, &quot;c&quot;, &quot;s&quot;,], [&quot;j&quot;, &quot;d&quot;, &quot;e&quot;, &quot;h&quot;]]</code>矩阵中包含一条字符串”bfce”的路径，但是矩阵中不包含”abfb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</li>
<li><strong>思路</strong>：回溯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hasPath</span>(<span class="params">matrix, rows, columns, target_path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(target_path) == <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    first_candidates = [] <span class="comment"># [(r1, c1), (r2, c2), ...]</span></span><br><span class="line">    <span class="comment"># 搜索第一个点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columns):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target_path[<span class="number">0</span>]:</span><br><span class="line">                first_candidates.append((i, j))</span><br><span class="line">    <span class="comment"># 第一个点搜索失败</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(first_candidates) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 搜索剩下所有点</span></span><br><span class="line">    <span class="keyword">for</span> r, c <span class="keyword">in</span> first_candidates:</span><br><span class="line">        <span class="keyword">if</span> hasPathCore(matrix, rows, columns, target_path, [(r, c)]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hasPathCore</span>(<span class="params">matrix, rows, columns, target_path, cur_path</span>):</span><br><span class="line">    <span class="comment"># 已经搜索完毕</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(target_path) == <span class="built_in">len</span>(cur_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    target_char = target_path[<span class="built_in">len</span>(cur_path)]</span><br><span class="line">    <span class="comment"># 确定这步的搜索空间</span></span><br><span class="line">    possible_points = []</span><br><span class="line">    cur_point = cur_path[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> cur_point[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        possible_point = (cur_point[<span class="number">0</span>] - <span class="number">1</span>, cur_point[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> possible_point <span class="keyword">not</span> <span class="keyword">in</span> cur_path:   </span><br><span class="line">            possible_points.append(possible_point)</span><br><span class="line">    <span class="keyword">if</span> cur_point[<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        possible_point = (cur_point[<span class="number">0</span>], cur_point[<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> possible_point <span class="keyword">not</span> <span class="keyword">in</span> cur_path:   </span><br><span class="line">            possible_points.append(possible_point)</span><br><span class="line">    <span class="keyword">if</span> cur_point[<span class="number">0</span>] &lt; rows - <span class="number">1</span>:</span><br><span class="line">        possible_point = (cur_point[<span class="number">0</span>] + <span class="number">1</span>, cur_point[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> possible_point <span class="keyword">not</span> <span class="keyword">in</span> cur_path:   </span><br><span class="line">            possible_points.append(possible_point)</span><br><span class="line">    <span class="keyword">if</span> cur_point[<span class="number">1</span>] &lt; columns - <span class="number">1</span>:</span><br><span class="line">        possible_point = (cur_point[<span class="number">0</span>], cur_point[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> possible_point <span class="keyword">not</span> <span class="keyword">in</span> cur_path:   </span><br><span class="line">            possible_points.append(possible_point)</span><br><span class="line">    <span class="comment"># 搜索空间为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(possible_points) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 搜索一步</span></span><br><span class="line">    <span class="keyword">for</span> possible_point <span class="keyword">in</span> possible_points:</span><br><span class="line">        <span class="comment"># 该步搜索成功</span></span><br><span class="line">        <span class="keyword">if</span> matrix[possible_point[<span class="number">0</span>]][possible_point[<span class="number">1</span>]] == target_char:</span><br><span class="line">            <span class="comment"># 搜索后续</span></span><br><span class="line">            <span class="keyword">if</span> hasPathCore(matrix, rows, columns, target_path, cur_path + [possible_point]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_matrix = [[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;g&quot;</span>], [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;s&quot;</span>,], [<span class="string">&quot;j&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;h&quot;</span>]]</span><br><span class="line"><span class="built_in">print</span>(hasPath(test_matrix, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;bfce&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(hasPath(test_matrix, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;abfb&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="NO-13-机器人的运动范围"><a href="#NO-13-机器人的运动范围" class="headerlink" title="NO.13 机器人的运动范围"></a>NO.13 机器人的运动范围</h2><ul>
<li><strong>问题描述</strong>：地上有一个m行和n列的方格。一个机器人从坐标<code>(0,0)</code>的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够达到多少个格子？例如，当k为18时，机器人能够进入方格<code>(35,37)</code>，因为<code>3+5+3+7=18</code>。但是，它不能进入方格<code>(35,38)</code>，因为<code>3+5+3+8=19</code>。</li>
<li><strong>思路</strong>：回溯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">movingCount</span>(<span class="params">threshold, rows, cols</span>):</span><br><span class="line">    <span class="keyword">if</span> rows &lt;=<span class="number">0</span> <span class="keyword">or</span> cols &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果没有访问过设为0，访问过设为1，不合法设为-1。</span></span><br><span class="line">    reach_matrix = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">    movingCountCore(reach_matrix, threshold, rows, cols, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            <span class="keyword">if</span> reach_matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reach_matrix:&quot;</span>, reach_matrix)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">movingCountCore</span>(<span class="params">reach_matrix, threshold, rows, cols, cur_point</span>):</span><br><span class="line">    possible_next_points = getPossibleNextPoints(reach_matrix, rows, cols, cur_point)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(possible_next_points) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> possible_next_points:</span><br><span class="line">        <span class="keyword">if</span> checkIsLegal(threshold, point):</span><br><span class="line">            <span class="comment"># 如果合法，记录记为1，且继续探索</span></span><br><span class="line">            reach_matrix[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">            movingCountCore(reach_matrix, threshold, rows, cols, point)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果不合法，记录为-1，且停止改点后续的探索</span></span><br><span class="line">            reach_matrix[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPossibleNextPoints</span>(<span class="params">reach_matrix, rows, cols, cur_point</span>):</span><br><span class="line">    r = cur_point[<span class="number">0</span>]</span><br><span class="line">    c = cur_point[<span class="number">1</span>]</span><br><span class="line">    possible_next_points = []</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">and</span> reach_matrix[r - <span class="number">1</span>][c] == <span class="number">0</span>:</span><br><span class="line">        possible_next_points.append((r - <span class="number">1</span>, c))</span><br><span class="line">    <span class="keyword">if</span> c &gt; <span class="number">0</span> <span class="keyword">and</span> reach_matrix[r][c - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        possible_next_points.append((r, c - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> r &lt; rows - <span class="number">1</span> <span class="keyword">and</span> reach_matrix[r + <span class="number">1</span>][c] == <span class="number">0</span>:</span><br><span class="line">        possible_next_points.append((r + <span class="number">1</span>, c))</span><br><span class="line">    <span class="keyword">if</span> c &lt; cols - <span class="number">1</span> <span class="keyword">and</span> reach_matrix[r][c + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        possible_next_points.append((r, c + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> possible_next_points</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkIsLegal</span>(<span class="params">threshold, point</span>):</span><br><span class="line">    r = point[<span class="number">0</span>]</span><br><span class="line">    c = point[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> getDigitSum(r) + getDigitSum(c) &lt;= threshold</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDigitSum</span>(<span class="params">num</span>):</span><br><span class="line">    res = num % <span class="number">10</span></span><br><span class="line">    <span class="keyword">while</span> num // <span class="number">10</span> != <span class="number">0</span>:</span><br><span class="line">        num = num // <span class="number">10</span></span><br><span class="line">        res += num % <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movingCount(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reach_matrix: [[1, 1, 1], [1, 1, -1], [1, -1, 0]]</span><br><span class="line"></span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>使用动态规划的问题的<strong>三个特点</strong>：</p>
<ul>
<li>1.问题本身是求解一个最优解。</li>
<li>2.这个最优解依赖于各个子问题的最优解。</li>
<li>3.大问题可以分解成若干小问题，小问题之间还有相互重叠的更小的子问题。</li>
</ul>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>贪婪算法解决问题：每一步都可以做出一个<strong>贪婪</strong>的选择，基于这个选择，我们确定能够得到最优解。与此同时，我们必须要用数学方式证明贪婪选择是正确的。</p>
<h2 id="NO-14-剪绳子"><a href="#NO-14-剪绳子" class="headerlink" title="NO.14 剪绳子"></a>NO.14 剪绳子</h2><ul>
<li><strong>问题描述</strong>：给定一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为<code>k[0],k[1],…,k[m]</code>。请问<code>k[0]* k[1] * … *k[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</li>
<li><strong>思路</strong>：动态规划。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProductAfterCuttingDP</span>(<span class="params">length</span>):</span><br><span class="line">    max_product = <span class="built_in">list</span>(<span class="built_in">range</span>(length + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            candidate = max_product[j] * max_product[i - j]</span><br><span class="line">            <span class="keyword">if</span> candidate &gt; max_product[i]:</span><br><span class="line">                max_product[i] = candidate</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;max_product: &quot;</span>, max_product)</span><br><span class="line">    <span class="keyword">return</span> max_product[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxProductAfterCuttingDP(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max_product:  [0, 1, 2, 3, 4, 6, 9, 12, 18]</span><br><span class="line"></span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<h3 id="贪婪算法解法"><a href="#贪婪算法解法" class="headerlink" title="贪婪算法解法"></a>贪婪算法解法</h3><ul>
<li><strong>思路</strong>：贪婪算法。</li>
<li><strong>时间复杂度</strong>：$O(1)$ </li>
<li>策略：当$n\geq5$时，尽可能多地将剪绳子成长度为3；当剩下的绳子长度是4时，把绳子剪成两段长度是2的绳子。</li>
<li>证明：当$n\geq 5$时，$2(n-2)\geq n$，$3(n-3)\geq n$且$3(n-3)\geq 2(n-2)$。但如果长度剪成其他大于3的长度，则一定可以用剪成两段2或者更多的3来替代。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProductAfterCuttingGreedy</span>(<span class="params">length</span>):</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># 尽可能多地剪成长度是3的绳子</span></span><br><span class="line">    times_of_3 = length // <span class="number">3</span></span><br><span class="line">    <span class="comment"># 此时的方案是将绳子剪成长度是2的两段，因为2*2 &gt; 3*1</span></span><br><span class="line">    <span class="keyword">if</span> length - times_of_3 * <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">        times_of_3 -= <span class="number">1</span></span><br><span class="line">    times_of_2 = (length - times_of_3 * <span class="number">3</span>) // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;times_of_3: &quot;</span>, times_of_3, <span class="string">&quot;times_of_2: &quot;</span>, times_of_2)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, times_of_3) * <span class="built_in">pow</span>(<span class="number">2</span>, times_of_2)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxProductAfterCuttingGreedy(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">times_of_3:  2 times_of_2:  1</span><br><span class="line"></span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<h2 id="NO-15-二进制中1的个数"><a href="#NO-15-二进制中1的个数" class="headerlink" title="NO.15 二进制中1的个数"></a>NO.15 二进制中1的个数</h2><ul>
<li><strong>问题描述</strong>：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</li>
<li><strong>思路</strong>：设置一个对比的数，flag，从1开始，每次右移一位，每次与原数字做与运算。</li>
<li><strong>优点</strong>：简单，且能解决负数的情况。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">NumberOfOne</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    flag = <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> flag <span class="keyword">and</span> i &lt; <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">if</span> n &amp; flag:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">#         print flag, count</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumberOfOne(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="NO-16-数值的整数次方"><a href="#NO-16-数值的整数次方" class="headerlink" title="NO.16 数值的整数次方"></a>NO.16 数值的整数次方</h2><ul>
<li><strong>问题描述</strong>：实现函数double Power（double base, int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</li>
<li><strong>思路</strong>：当$n$为奇数：$x^n&#x3D;(x^2)^{n&#x2F;2}×x$；当$n$为偶数：$x^n&#x3D;(x^2)^{n&#x2F;2}$</li>
<li><strong>优点</strong>：节省乘法的次数。</li>
<li><strong>时间复杂度</strong>：$O(logn)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Power</span>(<span class="params">x, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;x^n&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> n &lt; <span class="number">0</span>:  <span class="comment"># 0的负数次方不合理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    abs_n = <span class="built_in">abs</span>(n)</span><br><span class="line">    res = PowerWithAbsExponent(x, abs_n)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        res = <span class="number">1.0</span>/res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PowerWithAbsExponent</span>(<span class="params">x, abs_n</span>):</span><br><span class="line">    <span class="keyword">if</span> abs_n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> abs_n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    res = PowerWithAbsExponent(x, abs_n&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    res *= res</span><br><span class="line">    <span class="keyword">if</span> abs_n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">        res *= x</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Power(<span class="number">12</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1728</span><br></pre></td></tr></table></figure>

<h2 id="NO-17-打印1到最大的n位数"><a href="#NO-17-打印1到最大的n位数" class="headerlink" title="NO.17 打印1到最大的n位数"></a>NO.17 打印1到最大的n位数</h2><ul>
<li><strong>问题描述</strong>：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</li>
<li><strong>陷阱</strong>：这个问题属于<strong>大数类</strong>的问题，即给定n过大，n位的整数肯定不能用长整型保存。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Print1ToMaxOfNDigitsWrong</span>(<span class="params">n</span>):</span><br><span class="line">    end = <span class="built_in">pow</span>(<span class="number">10</span>, n)</span><br><span class="line">    <span class="built_in">print</span>(end)</span><br><span class="line"><span class="comment">#     for i in range(1, end):</span></span><br><span class="line"><span class="comment">#         print(i, end=&quot; &quot;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print1ToMaxOfNDigitsWrong(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>但是这种题好像对python没有影响。。。</p>
<ul>
<li><strong>思路</strong>：转换成<strong>全排列</strong>问题，使用<strong>递归</strong>完美解决。(有点像深度优先遍历)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Print1ToMaxOfNDigits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    number = [<span class="string">&quot;0&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        number[<span class="number">0</span>] = <span class="built_in">str</span>(i)</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Print1ToMaxOfNDigitsRecursively</span>(<span class="params">number, l, index</span>):</span><br><span class="line">    <span class="comment"># 已经遍历到最后一位数字，则打印出该数字</span></span><br><span class="line">    <span class="keyword">if</span> index == l - <span class="number">1</span>:</span><br><span class="line">        printNumber(number)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 否则继续深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        number[index + <span class="number">1</span>] = <span class="built_in">str</span>(i)</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, l, index + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printNumber</span>(<span class="params">number</span>):</span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> number[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> <span class="built_in">len</span>(number) &gt; <span class="number">1</span>:</span><br><span class="line">        number = number[<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(number), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print1ToMaxOfNDigits(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99</span><br></pre></td></tr></table></figure>

<h2 id="NO-18-在O（1）时间删除链表结点"><a href="#NO-18-在O（1）时间删除链表结点" class="headerlink" title="NO.18 在O（1）时间删除链表结点"></a>NO.18 在O（1）时间删除链表结点</h2><ul>
<li><strong>问题描述</strong>：给定单向链表的头指针和一个结点指针，定义一个函数在$O(1)$时间删除该结点</li>
<li><strong>思路</strong>：普通思路：从头遍历，找到当前节点的前一个节点，将这个节点指向当前节点的下一个节点，时间复杂度$O(n)$。优秀思路：将当前节点的写一个节点的值拷贝到当前节点，删除下一个节点。</li>
<li><strong>陷阱</strong>：如果要删除的是最后一个节点，解决方案需要调整。</li>
<li><strong>优点</strong>：时间复杂度低。</li>
<li><strong>缺点</strong>：这种方式采用拷贝的形式，改变了之前节点的对象。</li>
<li><strong>时间复杂度</strong>：$O(1)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">list_head, node_to_delete</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;删除链表中的指定节点。</span></span><br><span class="line"><span class="string">    注意，这里判断两个节点是否相同的方式仅仅是判断两个节点的值是否相同。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> list_head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node_to_delete <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> list_head</span><br><span class="line">    <span class="comment"># 如果要删除的是最后一个节点，则需要从头开始找</span></span><br><span class="line">    <span class="keyword">if</span> node_to_delete.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> node_to_delete.val == list_head.val:</span><br><span class="line">            <span class="keyword">del</span> node_to_delete, list_head</span><br><span class="line">            list_head = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> list_head</span><br><span class="line">        cur_node = list_head</span><br><span class="line">        <span class="keyword">while</span> cur_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> cur_node.<span class="built_in">next</span>.val != node_to_delete.val:</span><br><span class="line">            cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> cur_node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> cur_node.<span class="built_in">next</span>.val == node_to_delete.val:</span><br><span class="line">            cur_node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">del</span> node_to_delete</span><br><span class="line">        <span class="keyword">return</span> list_head</span><br><span class="line">    <span class="comment"># 将当前节点的写一个节点的值拷贝到当前节点，删除下一个节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        next_node = node_to_delete.<span class="built_in">next</span></span><br><span class="line">        node_to_delete.<span class="built_in">next</span> = next_node.<span class="built_in">next</span></span><br><span class="line">        node_to_delete.val = next_node.val</span><br><span class="line">        <span class="keyword">del</span> next_node</span><br><span class="line">        <span class="keyword">return</span> list_head</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">new_head = deleteNode(n1, n1)</span><br><span class="line">print_list(new_head)</span><br><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line">n4.<span class="built_in">next</span> = n5</span><br><span class="line">new_head = deleteNode(n1, n3)</span><br><span class="line">print_list(new_head)</span><br><span class="line">new_head = deleteNode(new_head, n5)</span><br><span class="line">print_list(new_head)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This node list is empty!</span><br><span class="line">1 2 4 5</span><br><span class="line">1 2 4</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_node = ListNode(<span class="number">3</span>)</span><br><span class="line">new_node.<span class="built_in">next</span> = n3.<span class="built_in">next</span></span><br><span class="line">new_node == n3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="NO-19-正则表达式匹配"><a href="#NO-19-正则表达式匹配" class="headerlink" title="NO.19 正则表达式匹配"></a>NO.19 正则表达式匹配</h2><ul>
<li><strong>问题描述</strong>：请实现一个函数用来匹配包括<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现<strong>任意次（包含0次）</strong>。在本题中，匹配是指字符串的<strong>所有字符匹配整个模式</strong>。例如，字符串”aaa”与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但是与<code>aa.a</code>和<code>ab*a</code>均不匹配。</li>
<li><strong>思路</strong>：递归、非确定有限状态机。</li>
<li><strong>优点</strong>：思路清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">string, pattern</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> matchCore(string, pattern)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matchCore</span>(<span class="params">string, pattern</span>):</span><br><span class="line">    <span class="comment"># 完整匹配结束</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 模板匹配结束，还有剩余的字符串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 字符串匹配结束，只有pattern的长度既是2的整数倍，且是&quot;a*b*&quot;之类才可以匹配</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> pattern[-<span class="number">1</span>] != <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> <span class="built_in">len</span>(pattern) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pattern) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> matchCore(string, pattern[<span class="number">2</span>:])</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 前两个字符没有*的情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pattern) &lt; <span class="number">2</span> <span class="keyword">or</span> pattern[<span class="number">1</span>] != <span class="string">&quot;*&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] == string[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> matchCore(string[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 第二个字符是*的情况</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 第一个字符也匹配上</span></span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] == string[<span class="number">0</span>] <span class="keyword">or</span> (pattern[<span class="number">0</span>] == <span class="string">&quot;.&quot;</span> <span class="keyword">and</span> <span class="built_in">len</span>(string) &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 丢掉第一个匹配的字符，进入下一个状态</span></span><br><span class="line">            <span class="keyword">if</span> matchCore(string[<span class="number">1</span>:], pattern[<span class="number">2</span>:]):  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 继续保留第一个匹配的字符，进入下一个状态</span></span><br><span class="line">            <span class="keyword">if</span> matchCore(string, pattern[<span class="number">2</span>:]):  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 或者继续停留在这个状态</span></span><br><span class="line">            <span class="keyword">if</span> matchCore(string[<span class="number">1</span>:], pattern):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 第一个字符匹配不上，必须进入下一个状态</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(string, pattern[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;a.a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;ab*ac*a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aa.a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;ab*a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;ab*a*&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="NO-20-表示数值的字符串"><a href="#NO-20-表示数值的字符串" class="headerlink" title="NO.20 表示数值的字符串"></a>NO.20 表示数值的字符串</h2><ul>
<li><strong>问题描述</strong>：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</li>
<li><strong>思路</strong>：表示数字的字符串遵循模式<code>A[.[B]][e|EC]</code>或者<code>.B[e|EC]</code>，其中A为数值的整数部分，B紧跟着小数点为数值的小数部分，C紧跟e或者E是数值的指数部分。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scanUnsignedInteger</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(string) <span class="keyword">and</span> string[i].isdigit():</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i &gt; <span class="number">0</span>, i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanInteger</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> string[<span class="number">0</span>] == <span class="string">&quot;-&quot;</span> <span class="keyword">or</span> string[<span class="number">0</span>] == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        found, index = scanUnsignedInteger(string[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> found, index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isNumeric</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    found_1 = found_2 = found_3 = <span class="literal">False</span></span><br><span class="line">    found_1, index = scanInteger(string)</span><br><span class="line">    string = string[index:]</span><br><span class="line">    is_numeric = found_1</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果出现&#x27;.&#x27;，则接下来是小数部分</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) &gt; <span class="number">0</span> <span class="keyword">and</span> string[<span class="number">0</span>] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">        string = string[<span class="number">1</span>:]</span><br><span class="line">        found_2, index = scanUnsignedInteger(string)</span><br><span class="line">        string = string[index:]</span><br><span class="line">        <span class="comment"># 使用&#x27;or&#x27;的原因：小数点前面或者后面都可以没有数字</span></span><br><span class="line">        is_numeric = found_2 <span class="keyword">or</span> is_numeric</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 如果出现&#x27;e&#x27;或者&#x27;E&#x27;，则接下来的数字是指数部分</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(string) &gt; <span class="number">0</span> <span class="keyword">and</span> (string[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> string[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>):</span><br><span class="line">        string = string[<span class="number">1</span>:]</span><br><span class="line">        found_3, index = scanInteger(string)</span><br><span class="line">        string = string[index:]</span><br><span class="line">        <span class="comment"># 使用&#x27;and&#x27;的原因：e的前面或者后面没有数字，都不合法</span></span><br><span class="line">        is_numeric = found_3 <span class="keyword">and</span> is_numeric</span><br><span class="line">    </span><br><span class="line"><span class="comment">#     print(&quot;found_1: &quot;, found_1, &quot;,found_2: &quot;, found_2, &quot;,found_3: &quot;, found_3, &quot;is_numeric: &quot;, is_numeric)</span></span><br><span class="line">    <span class="keyword">return</span> is_numeric <span class="keyword">and</span> <span class="built_in">len</span>(string) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正例</span></span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;+100&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;5e2&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;-123&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;3.1416&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;-1E-16&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 反例</span></span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;12e&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;1a3.14&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;1.2.3&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;+-5&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(isNumeric(<span class="string">&quot;12e+4.3&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="NO-21-调整数组顺序使奇数位于偶数前面"><a href="#NO-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="NO.21 调整数组顺序使奇数位于偶数前面"></a>NO.21 调整数组顺序使奇数位于偶数前面</h2><ul>
<li><strong>问题描述</strong>：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</li>
<li><strong>思路</strong>：看到这题想到了快排的partition，只不过一个标准是小的在前，大的在后面。提示：双指针。</li>
<li><strong>优点</strong>：可扩展性高。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Reorder</span>(<span class="params">data, reorder_func</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">or</span> reorder_func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    e = l - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s &lt; e:</span><br><span class="line">        <span class="keyword">while</span> s &lt; e <span class="keyword">and</span> <span class="keyword">not</span> reorder_func(data[s]):</span><br><span class="line">            s += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> s &lt; e <span class="keyword">and</span> reorder_func(data[e]):</span><br><span class="line">            e -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s &lt; e:</span><br><span class="line">            data[s], data[e] = data[e], data[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isEven</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReorderOddEven</span>(<span class="params">data</span>):</span><br><span class="line">    Reorder(data, isEven)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">ReorderOddEven(test_data)</span><br><span class="line"><span class="built_in">print</span>(test_data)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 3, 4, 2]</span><br></pre></td></tr></table></figure>

<h2 id="NO-22-链表中倒数第k个节点"><a href="#NO-22-链表中倒数第k个节点" class="headerlink" title="NO.22 链表中倒数第k个节点"></a>NO.22 链表中倒数第k个节点</h2><ul>
<li><strong>问题描述</strong>：输入一个链表，输出该链表中倒数第k个结点。为符合计数习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。如：一个链表有6个节点，从头节点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</li>
<li><strong>思路</strong>：两个指针。</li>
<li><strong>陷阱</strong>：如果链表长度小于k会不会有问题？</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findKthToTail</span>(<span class="params">head_node, k</span>):</span><br><span class="line">    <span class="keyword">if</span> head_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, -<span class="number">1</span></span><br><span class="line">    ahead = head_node</span><br><span class="line">    behind = head_node</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> ahead.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            ahead = ahead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> ahead.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ahead = ahead.<span class="built_in">next</span></span><br><span class="line">        behind = behind.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>, behind.val</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n6 = ListNode(<span class="number">6</span>)</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line">n4.<span class="built_in">next</span> = n5</span><br><span class="line">n5.<span class="built_in">next</span> = n6</span><br><span class="line"><span class="built_in">print</span>(findKthToTail(n1, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(findKthToTail(n1, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(findKthToTail(n1, <span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(True, 4)</span><br><span class="line">(False, -1)</span><br><span class="line">(False, -1)</span><br></pre></td></tr></table></figure>

<h2 id="NO-23-链表中环的入口节点"><a href="#NO-23-链表中环的入口节点" class="headerlink" title="NO.23 链表中环的入口节点"></a>NO.23 链表中环的入口节点</h2><ul>
<li><strong>问题描述</strong>：如果一个链表中包含环，请找出该链表的环的入口结点。如：在1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;3的链表中，包含一个环，环的入口节点是3。</li>
<li><strong>思路</strong>：先确定环的长度$n$，再确定入口位置（用$k$表示从起点到入口的距离）。1：使用两个速度不一样的指针取遍历，当二者相遇时，说明被<strong>套圈了</strong>。套圈说明差距是$n$的整数倍，不能保证一定是$n$；但套圈还说明了<strong>相遇的点一定在环中</strong>，在这个节点上重新开始遍历，回到本身时，遍历次数即是长度。2：使用同样速度一前一后的两个指针，前面的指针先走$n$步，然后后面的指针和前面的指针一起走，当二者第一次相遇时，慢指针正好走了$k$步，快指针走了$n+k$步，都在环入口处。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">meetingNode</span>(<span class="params">headNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在存在环的前提下，找到一快一慢两个指针相遇的节点。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> headNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    slow = headNode.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> slow <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    fast = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> slow <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">entryNodeOfLoop</span>(<span class="params">headNode</span>):</span><br><span class="line">    meeting_node = MeetingNode(headNode)</span><br><span class="line">    <span class="keyword">if</span> meeting_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算环的长度</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    node = meeting_node</span><br><span class="line">    <span class="keyword">while</span> node.<span class="built_in">next</span> != meeting_node:</span><br><span class="line">        node = node.<span class="built_in">next</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 先移动前面的指针n次</span></span><br><span class="line">    ahead = headNode</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        ahead = ahead.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 再同时移动两个指针，直到相遇</span></span><br><span class="line">    behind = headNode</span><br><span class="line">    <span class="keyword">while</span> ahead != behind:</span><br><span class="line">        ahead = ahead.<span class="built_in">next</span></span><br><span class="line">        behind = behind.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ahead</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n6 = ListNode(<span class="number">6</span>)</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line">n4.<span class="built_in">next</span> = n5</span><br><span class="line">n5.<span class="built_in">next</span> = n6</span><br><span class="line">n6.<span class="built_in">next</span> = n3</span><br><span class="line">entry = entryNodeOfLoop(n1)</span><br><span class="line"><span class="built_in">print</span>(entry.val)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="NO-24-反转链表"><a href="#NO-24-反转链表" class="headerlink" title="NO.24 反转链表"></a>NO.24 反转链表</h2><ul>
<li><strong>问题描述</strong>：输入一个链表的头节点，反转链表并输出反转链表的头节点。</li>
<li><strong>思路</strong>：递归。</li>
<li><strong>优点</strong>：思路简单。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseListRecursive</span>(<span class="params">headNode</span>):</span><br><span class="line">    <span class="keyword">if</span> headNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> headNode.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> headNode, headNode</span><br><span class="line">    new_tail, new_head = reverseListRecursive(headNode.<span class="built_in">next</span>)</span><br><span class="line">    new_tail.<span class="built_in">next</span> = headNode</span><br><span class="line">    headNode.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> headNode, new_head</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n6 = ListNode(<span class="number">6</span>)</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line">n4.<span class="built_in">next</span> = n5</span><br><span class="line">n5.<span class="built_in">next</span> = n6</span><br><span class="line">new_tail, new_head = reverseListRecursive(n1)</span><br><span class="line">print_list(new_head)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 5 4 3 2 1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路</strong>：也可以直接正向遍历。</li>
<li><strong>优点</strong>：运行开销没有递归大。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">headNode</span>):</span><br><span class="line">    <span class="keyword">if</span> headNode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">if</span> headNode.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> headNode</span><br><span class="line">    prevNode = headNode</span><br><span class="line">    node = headNode.<span class="built_in">next</span></span><br><span class="line">    headNode.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> node.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">        nextNode = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span> = prevNode</span><br><span class="line">        prevNode = node</span><br><span class="line">        node = nextNode</span><br><span class="line">    node.<span class="built_in">next</span> = prevNode</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n6 = ListNode(<span class="number">6</span>)</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line">n4.<span class="built_in">next</span> = n5</span><br><span class="line">n5.<span class="built_in">next</span> = n6</span><br><span class="line">new_head = reverseList(n1)</span><br><span class="line">print_list(new_head)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 5 4 3 2 1</span><br></pre></td></tr></table></figure>

<h2 id="NO-25-合并两个排序的链表"><a href="#NO-25-合并两个排序的链表" class="headerlink" title="NO.25 合并两个排序的链表"></a>NO.25 合并两个排序的链表</h2><ul>
<li><strong>问题描述</strong>：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调递增规则。如：链表1：1-&gt;3-&gt;5；链表2：2-&gt;4-&gt;6；合并后为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6。</li>
<li><strong>思路</strong>：递归。</li>
<li><strong>优点</strong>：思路清晰。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeList</span>(<span class="params">head1, head2</span>):</span><br><span class="line">    <span class="keyword">if</span> head1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head2</span><br><span class="line">    <span class="keyword">if</span> head2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head1</span><br><span class="line">    <span class="keyword">if</span> head1.val &lt; head2.val:</span><br><span class="line">        new_head = mergeList(head1.<span class="built_in">next</span>, head2)</span><br><span class="line">        head1.<span class="built_in">next</span> = new_head</span><br><span class="line">        <span class="keyword">return</span> head1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_head = mergeList(head1, head2.<span class="built_in">next</span>)</span><br><span class="line">        head2.<span class="built_in">next</span> = new_head</span><br><span class="line">        <span class="keyword">return</span> head2</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n6 = ListNode(<span class="number">6</span>)</span><br><span class="line">n1.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n5</span><br><span class="line">n2.<span class="built_in">next</span> = n4</span><br><span class="line">n4.<span class="built_in">next</span> = n6</span><br><span class="line">new_head = mergeList(n1, n2)</span><br><span class="line">print_list(new_head)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>

<h2 id="NO-26-树的子结构"><a href="#NO-26-树的子结构" class="headerlink" title="NO.26 树的子结构"></a>NO.26 树的子结构</h2><ul>
<li><strong>问题描述</strong>：输入两棵二叉树A和B，判断B是不是A的子结构。</li>
<li><strong>思路</strong>：分成两步：1.在A中找到和B的根节点的值一样的节点R；2.判断A中以R为根节点的子树是不是包含和B一样的结构。</li>
<li><strong>时间复杂度</strong>：$O(n×m)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hasSubtree</span>(<span class="params">root1, root2</span>):</span><br><span class="line">    res = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> root1.val == root2.val:</span><br><span class="line">            res = doesTree1HasTree2(root1, root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            res = hasSubtree(root1.left, root2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            res = hasSubtree(root1.right, root2)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doesTree1HasTree2</span>(<span class="params">root1, root2</span>):</span><br><span class="line">    <span class="keyword">if</span> root2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> root1.val != root2.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> doesTree1HasTree2(root1.left, root2.left) <span class="keyword">and</span> doesTree1HasTree2(root1.right, root2.right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">2</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">4</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">n8 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n9 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n10 = TreeNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n5.left = n6</span><br><span class="line">n6.right = n7</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"></span><br><span class="line">n8.left = n9</span><br><span class="line">n8.right = n10</span><br><span class="line"></span><br><span class="line">print_tree(n8)</span><br><span class="line"></span><br><span class="line">hasSubtree(n1, n8)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8 8 7 9 2 4 7</span><br><span class="line">8 9 2</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="NO-27-二叉树的镜像"><a href="#NO-27-二叉树的镜像" class="headerlink" title="NO.27 二叉树的镜像"></a>NO.27 二叉树的镜像</h2><ul>
<li><strong>问题描述</strong>：输入一棵二叉树，输出它的镜像。</li>
<li><strong>思路</strong>：递归。</li>
<li><strong>优点</strong>：思路清晰。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mirrorRecursively</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    root.right, root.left = root.left, root.right</span><br><span class="line">    mirrorRecursively(root.right)</span><br><span class="line">    mirrorRecursively(root.left)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"></span><br><span class="line">mirrorRecursively(n1)</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 6 10 5 7 9 11</span><br><span class="line">8 10 6 11 9 7 5</span><br></pre></td></tr></table></figure>

<h2 id="NO-28-对称的二叉树"><a href="#NO-28-对称的二叉树" class="headerlink" title="NO.28 对称的二叉树"></a>NO.28 对称的二叉树</h2><ul>
<li><strong>问题描述</strong>：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</li>
<li><strong>思路</strong>：递归。</li>
<li><strong>优点</strong>：思路清晰。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isTreeSymmetrical</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> isTwoTreeSymmetrical(root, root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isTwoTreeSymmetrical</span>(<span class="params">root1, root2</span>):</span><br><span class="line">    <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> root1.val != root2.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> isTwoTreeSymmetrical(root1.left, root2.right) <span class="keyword">and</span> isTwoTreeSymmetrical(root1.right, root2.left)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"><span class="built_in">print</span>(isTreeSymmetrical(n1))</span><br><span class="line"></span><br><span class="line">n3.val = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"><span class="built_in">print</span>(isTreeSymmetrical(n1))</span><br><span class="line"></span><br><span class="line">n3.val = <span class="number">6</span></span><br><span class="line">n3.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"><span class="built_in">print</span>(isTreeSymmetrical(n1))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8 6 6 5 7 7 5</span><br><span class="line">True</span><br><span class="line">8 6 9 5 7 7 5</span><br><span class="line">False</span><br><span class="line">8 6 6 5 7 7</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="NO-29-顺时针打印矩阵"><a href="#NO-29-顺时针打印矩阵" class="headerlink" title="NO.29 顺时针打印矩阵"></a>NO.29 顺时针打印矩阵</h2><ul>
<li><strong>问题描述</strong>：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</li>
<li><strong>思路</strong>：此题没有复杂的思路，只需需注意每一步的条件判断，简单但易错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PrintMatrixClockwisely</span>(<span class="params">numbers, columns, rows</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> columns &lt;= <span class="number">0</span> <span class="keyword">or</span> rows &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> columns &gt; start * <span class="number">2</span> <span class="keyword">and</span> rows &gt; start * <span class="number">2</span>:</span><br><span class="line">        PrintMatrixInCircle(numbers, columns, rows, start);</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PrintMatrixInCircle</span>(<span class="params">numbers, columns, rows, start</span>):</span><br><span class="line">    endX = columns - <span class="number">1</span> - start</span><br><span class="line">    endY = rows - <span class="number">1</span> - start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从做到右打印一行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, endX+<span class="number">1</span>):</span><br><span class="line">        number = numbers[start][i]</span><br><span class="line">        <span class="built_in">print</span>(number, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 从上到下打印一行</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; endY:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start+<span class="number">1</span>, endY+<span class="number">1</span>):</span><br><span class="line">            number = numbers[i][endX]</span><br><span class="line">            <span class="built_in">print</span>(number, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 从右到左打印一行</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; endX <span class="keyword">and</span> start &lt; endY:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(endX-<span class="number">1</span>, start-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            number = numbers[endY][i]</span><br><span class="line">            <span class="built_in">print</span>(number, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 从下到上打印一行</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; endX <span class="keyword">and</span> start &lt; endY - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(endY-<span class="number">1</span>, start, -<span class="number">1</span>):</span><br><span class="line">            number = numbers[i][start]</span><br><span class="line">            <span class="built_in">print</span>(number, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">c = r = <span class="number">4</span></span><br><span class="line">PrintMatrixClockwisely(numbers, c, r)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</span><br></pre></td></tr></table></figure>

<h2 id="NO-30-包含min函数的栈"><a href="#NO-30-包含min函数的栈" class="headerlink" title="NO.30 包含min函数的栈"></a>NO.30 包含min函数的栈</h2><ul>
<li><strong>问题描述</strong>：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O（1）。</li>
<li><strong>思路</strong>：设置辅助栈，和当前栈保持一致的形状，保存栈在某状态下的最小值。</li>
<li><strong>优点</strong>：空间换时间。</li>
<li><strong>时间复杂度</strong>：$O(1)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.min_stack = []</span><br><span class="line">        <span class="variable language_">self</span>.data_stack = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.min_stack) == <span class="number">0</span> <span class="keyword">or</span> <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>] &gt; value:</span><br><span class="line">            <span class="variable language_">self</span>.min_stack.append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.min_stack.append(<span class="variable language_">self</span>.min_stack[-<span class="number">1</span>])</span><br><span class="line">        <span class="variable language_">self</span>.data_stack.append(value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.min_stack) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data_stack) &gt; <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.min_stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.data_stack.pop()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min_val</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.min_stack) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data_stack) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ms = MinStack()</span><br><span class="line">ms.push(<span class="number">3</span>)</span><br><span class="line">ms.push(<span class="number">2</span>)</span><br><span class="line">ms.push(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ms.min_val())</span><br><span class="line">ms.pop()</span><br><span class="line"><span class="built_in">print</span>(ms.min_val())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="NO-31-栈的压入、弹出序列"><a href="#NO-31-栈的压入、弹出序列" class="headerlink" title="NO.31 栈的压入、弹出序列"></a>NO.31 栈的压入、弹出序列</h2><ul>
<li><strong>问题描述</strong>：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</li>
<li><strong>思路</strong>：使用一个栈模拟压入和弹出的过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">IsPopOrder</span>(<span class="params">pushV, popV</span>):</span><br><span class="line">    stack = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> one_pop <span class="keyword">in</span> popV:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt;<span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == one_pop:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(pushV) <span class="keyword">and</span> one_pop != pushV[i]:</span><br><span class="line">                stack.append(pushV[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(pushV):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushV = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># popV = [5,4,3,2,1]</span></span><br><span class="line"><span class="comment"># popV = [2,5,4,3,1]</span></span><br><span class="line">popV = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">IsPopOrder(pushV, popV)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="NO-32-从上到下打印二叉树"><a href="#NO-32-从上到下打印二叉树" class="headerlink" title="NO.32 从上到下打印二叉树"></a>NO.32 从上到下打印二叉树</h2><ul>
<li><strong>问题描述</strong>：从上倒下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</li>
<li><strong>思路</strong>：使用一个队列。</li>
<li><strong>扩展</strong>：广度优先遍历一个有向图也是基于队列实现，但广度优先遍历一般必须要查重，树则没有这个问题。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printFromTopToBottom</span>(<span class="params">root</span>):</span><br><span class="line">    traverse = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is an empty tree!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        traverse.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.insert(<span class="number">0</span>, node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.insert(<span class="number">0</span>, node.right)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(one) <span class="keyword">for</span> one <span class="keyword">in</span> traverse]))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">printFromTopToBottom(n1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 6 10 5 7 9 11</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变体</strong>：分行从上到下打印二叉树</li>
<li><strong>问题描述</strong>：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</li>
<li><strong>思路</strong>：增加一个行结束的标识符。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printFromTopToBottomByLine</span>(<span class="params">root</span>):</span><br><span class="line">    traverse = []</span><br><span class="line">    line_end_token = <span class="string">&quot;&lt;END&gt;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is an empty tree!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    queue = [line_end_token, root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment">#         print(traverse)</span></span><br><span class="line">        node = queue.pop()</span><br><span class="line">        <span class="keyword">if</span> node == line_end_token:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(one) <span class="keyword">for</span> one <span class="keyword">in</span> traverse]))</span><br><span class="line">            traverse = []</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        traverse.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.insert(<span class="number">0</span>, node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.insert(<span class="number">0</span>, node.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> <span class="keyword">and</span> queue[-<span class="number">1</span>] == line_end_token:</span><br><span class="line">            queue.insert(<span class="number">0</span>, line_end_token)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">printFromTopToBottomByLine(n1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">6 10</span><br><span class="line">5 7 9 11</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变体</strong>：<strong>之字形</strong>打印二叉树</li>
<li><strong>问题描述</strong>：请实现一个函数按照之字形顺序打印二叉树。即第一行按照从左到右的顺序打印，第二行按照从右到左的顺序打印，第三行按照从左到右的顺序打印，以此类推。</li>
<li><strong>思路</strong>：用两个栈实现。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printFromTopToBottomByLineWithZHI</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用两个栈实现之字形层次遍历&quot;&quot;&quot;</span></span><br><span class="line">    traverse = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is an empty tree!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    cur_stack, son_stack = [root], []</span><br><span class="line">    is_left_to_right = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(cur_stack) &gt; <span class="number">0</span>:</span><br><span class="line">        node = cur_stack.pop()</span><br><span class="line">        traverse.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> is_left_to_right:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                son_stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                son_stack.append(node.right) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                son_stack.append(node.right) </span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                son_stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cur_stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(one) <span class="keyword">for</span> one <span class="keyword">in</span> traverse]))</span><br><span class="line">            traverse = []</span><br><span class="line">            cur_stack, son_stack = son_stack, []</span><br><span class="line">            is_left_to_right = <span class="keyword">not</span> is_left_to_right</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">printFromTopToBottomByLineWithZHI(n1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">10 6</span><br><span class="line">5 7 9 11</span><br></pre></td></tr></table></figure>

<h2 id="NO-33-二叉搜索树的后序遍历序列"><a href="#NO-33-二叉搜索树的后序遍历序列" class="headerlink" title="NO.33 二叉搜索树的后序遍历序列"></a>NO.33 二叉搜索树的后序遍历序列</h2><ul>
<li><strong>问题描述</strong>：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</li>
<li><strong>思路</strong>：后序遍历即左右根，搜索树满足：左&lt;根&lt;右。递归地判断是否满足条件。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">VarifySequenceOfBST</span>(<span class="params">seq</span>):</span><br><span class="line">    <span class="keyword">return</span> vs_core(seq, <span class="number">0</span>, <span class="built_in">len</span>(seq) - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vs_core</span>(<span class="params">seq, s, e</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(seq) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(seq) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    root = seq[e]</span><br><span class="line">    <span class="comment"># 判断左子树是否小于根</span></span><br><span class="line">    i = s</span><br><span class="line">    <span class="keyword">while</span> i &lt; e <span class="keyword">and</span> seq[i] &lt; root:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 记录左子树的最后一个点的下标</span></span><br><span class="line">    left_e = i - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 判断右子树是否大于根</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; e:</span><br><span class="line">        <span class="keyword">if</span> seq[i] &lt; root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 递归判断</span></span><br><span class="line">    is_left = <span class="literal">True</span></span><br><span class="line">    is_right = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> left_e &gt;= s:</span><br><span class="line">        is_left = vs_core(seq, s, left_e)</span><br><span class="line">    <span class="keyword">if</span> left_e + <span class="number">1</span> &lt; e:</span><br><span class="line">        is_right = vs_core(seq, left_e+<span class="number">1</span>, e-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> is_left <span class="keyword">and</span> is_right</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># seq = [5,7,6,9,11,10,8]</span></span><br><span class="line">seq = [<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">VarifySequenceOfBST(seq)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="NO-34-二叉树中和为某一值的路径"><a href="#NO-34-二叉树中和为某一值的路径" class="headerlink" title="NO.34 二叉树中和为某一值的路径"></a>NO.34 二叉树中和为某一值的路径</h2><ul>
<li><strong>问题描述</strong>：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</li>
<li><strong>思路</strong>：这道题是树状搜索最基础的原型。也可以理解成是<strong>回溯法</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">FindPath</span>(<span class="params">root, exp_sum</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    path = []</span><br><span class="line">    cur_sum = <span class="number">0</span></span><br><span class="line">    FindPathCore(root, exp_sum, path, cur_sum)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FindPathCore</span>(<span class="params">root, exp_sum, path, cur_sum</span>):</span><br><span class="line">    cur_sum += root.val</span><br><span class="line">    path.append(root.val)</span><br><span class="line">    is_leaf = root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> cur_sum == exp_sum <span class="keyword">and</span> is_leaf:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path)))</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        FindPathCore(root.left, exp_sum, path, cur_sum)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        FindPathCore(root.right, exp_sum, path, cur_sum)</span><br><span class="line">    path.pop()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">12</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">4</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">FindPath(n1, <span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 5 7</span><br><span class="line">10 12</span><br></pre></td></tr></table></figure>

<h2 id="NO-35-复杂链表的复制"><a href="#NO-35-复杂链表的复制" class="headerlink" title="NO.35 复杂链表的复制"></a>NO.35 复杂链表的复制</h2><ul>
<li><strong>问题描述</strong>：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空。节点使用<code>RandomListNode</code>类）</li>
<li><strong>思路</strong>：普通：如果一个一个取复制，那么特殊指针必须遍历到才能复制，因此时间复杂度太高，是$O(n^2)$。优秀：1.将链表复制为AA’BB’这种形式；2.将A’B’之间的链接从AB的链表上复制过来；3.再将两个链表分离。</li>
<li><strong>优点</strong>：时间复杂度低。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cloneCompleteNodes</span>(<span class="params">headNode</span>):</span><br><span class="line">    cloneNodes(headNode)</span><br><span class="line">    connectSiblingNodes(headNode)</span><br><span class="line">    <span class="keyword">return</span> reconnectNodes(headNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cloneNodes</span>(<span class="params">headNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将链表复制为AA&#x27;BB&#x27;这种形式&quot;&quot;&quot;</span></span><br><span class="line">    curNode = headNode</span><br><span class="line">    <span class="keyword">while</span> curNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        copyNode = RandomListNode(curNode.val)</span><br><span class="line">        copyNode.<span class="built_in">next</span> = curNode.<span class="built_in">next</span></span><br><span class="line">        curNode.<span class="built_in">next</span> = copyNode</span><br><span class="line">        curNode = copyNode.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connectSiblingNodes</span>(<span class="params">headNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将A&#x27;B&#x27;之间的链接从AB的链表上复制过来&quot;&quot;&quot;</span></span><br><span class="line">    curNode = headNode</span><br><span class="line">    <span class="keyword">while</span> curNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        copyNode = curNode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> curNode.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            copyNode.random = curNode.random.<span class="built_in">next</span></span><br><span class="line">        curNode = copyNode.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reconnectNodes</span>(<span class="params">headNode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;再将两个链表分离&quot;&quot;&quot;</span></span><br><span class="line">    curNode = headNode</span><br><span class="line">    <span class="keyword">if</span> curNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cloneHead = copyNode = curNode.<span class="built_in">next</span></span><br><span class="line">        curNode.<span class="built_in">next</span> = copyNode.<span class="built_in">next</span></span><br><span class="line">        curNode = curNode.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> curNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        copyNode.<span class="built_in">next</span> = curNode.<span class="built_in">next</span></span><br><span class="line">        copyNode = copyNode.<span class="built_in">next</span></span><br><span class="line">        curNode.<span class="built_in">next</span> = copyNode.<span class="built_in">next</span></span><br><span class="line">        curNode = curNode.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> cloneHead</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n1 = RandomListNode(<span class="number">1</span>)</span><br><span class="line">n2 = RandomListNode(<span class="number">2</span>)</span><br><span class="line">n3 = RandomListNode(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n1.random = n3</span><br><span class="line">n2.random = n1</span><br><span class="line"></span><br><span class="line">print_random_list(n1)</span><br><span class="line">n4 = cloneCompleteNodes(n1)</span><br><span class="line">print_random_list(n4)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val: 1, val of next: 2, val of random: 3 </span><br><span class="line">val: 2, val of next: 3, val of random: 1 </span><br><span class="line">val: 3, val of next: None, val of random: None </span><br><span class="line">val: 1, val of next: 2, val of random: 3 </span><br><span class="line">val: 2, val of next: 3, val of random: 1 </span><br><span class="line">val: 3, val of next: None, val of random: None </span><br></pre></td></tr></table></figure>

<h2 id="NO-36-二叉搜索树与双向链表"><a href="#NO-36-二叉搜索树与双向链表" class="headerlink" title="NO.36 二叉搜索树与双向链表"></a>NO.36 二叉搜索树与双向链表</h2><ul>
<li><strong>问题描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</li>
<li><strong>思路</strong>：二叉搜索树有一个特性：中序遍历二叉搜索树是排序好的数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Convert</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># last_node_in_list指向已经转换好的链表的最后一个节点（值最大的节点）</span></span><br><span class="line">    <span class="comment"># 放在list里实现引用传递</span></span><br><span class="line">    last_node_in_list = [<span class="literal">None</span>]</span><br><span class="line">    ConvertNode(root, last_node_in_list)</span><br><span class="line">    <span class="comment"># 找到头节点，并返回</span></span><br><span class="line">    head_node_in_list = last_node_in_list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> head_node_in_list <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head_node_in_list.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        head_node_in_list = head_node_in_list.left</span><br><span class="line">    <span class="keyword">return</span> head_node_in_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ConvertNode</span>(<span class="params">root, last_node_in_list</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ConvertNode(cur.left, last_node_in_list)</span><br><span class="line">    cur.left = last_node_in_list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> last_node_in_list[<span class="number">0</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        last_node_in_list[<span class="number">0</span>].right = cur</span><br><span class="line">    last_node_in_list[<span class="number">0</span>] = cur</span><br><span class="line">    <span class="keyword">if</span> cur.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        ConvertNode(cur.right, last_node_in_list)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">12</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">4</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">head = Convert(n1)</span><br><span class="line"><span class="keyword">while</span> head:</span><br><span class="line">    <span class="built_in">print</span>(head.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    head = head.right</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>.output n</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;name&quot;: &quot;stdout&quot;,</span><br><span class="line">  &quot;output_type&quot;: &quot;stream&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;4 5 7 10 12 &quot;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="NO-37-序列化二叉树"><a href="#NO-37-序列化二叉树" class="headerlink" title="NO.37 序列化二叉树"></a>NO.37 序列化二叉树</h2><ul>
<li><strong>问题描述</strong>：请实现两个函数，分别用来序列化和反序列化二叉树。</li>
<li><strong>思路</strong>：序列化：用前序遍历的顺序表示，并用一个特殊的符号如<code>$</code>表示空指针。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">root, s</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot;$,&quot;</span></span><br><span class="line">    s = s + <span class="built_in">str</span>(root.val) + <span class="string">&quot;,&quot;</span></span><br><span class="line">    s = serialize(root.left, s)</span><br><span class="line">    s = serialize(root.right, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">1</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">2</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">3</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">4</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n3.left = n5</span><br><span class="line">n3.right = n6</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(serialize(n1, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,4,$,$,$,3,5,$,$,6,$,$,</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> deserialize_core(s.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deserialize_core</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot;$&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, s[<span class="number">1</span>:]</span><br><span class="line">    node = TreeNode(s[<span class="number">0</span>])</span><br><span class="line">    node.left, s = deserialize_core(s[<span class="number">1</span>:])</span><br><span class="line">    node.right, s = deserialize_core(s)</span><br><span class="line">    <span class="keyword">return</span> node, s</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_str = <span class="string">&quot;1,2,4,$,$,$,3,5,$,$,6,$,$,&quot;</span></span><br><span class="line">root, s = deserialize(test_str)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">print_tree(root)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;&#x27;]</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>

<h2 id="NO-38-字符串的排列"><a href="#NO-38-字符串的排列" class="headerlink" title="NO.38 字符串的排列"></a>NO.38 字符串的排列</h2><ul>
<li><strong>问题描述</strong>：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</li>
<li><strong>思路</strong>：固定第一个，递归地求后面所有组合，然后将第一个字符和后面的元素互换，再做递归。</li>
<li><strong>空间复杂度</strong>：没有额外的浪费。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Permutation</span>(<span class="params">ss</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">or</span> <span class="built_in">len</span>(ss) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    set_ = <span class="built_in">set</span>()</span><br><span class="line">    ss = <span class="built_in">list</span>(ss)</span><br><span class="line">    fun(set_, ss, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> set_:</span><br><span class="line">        res.append(one)</span><br><span class="line">    res = <span class="built_in">sorted</span>(res)</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">set_, ss, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">len</span>(ss):</span><br><span class="line">        set_.add(<span class="string">&#x27;&#x27;</span>.join(ss))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(ss)):</span><br><span class="line">        swap(ss, i, k)</span><br><span class="line">        fun(set_, ss, k + <span class="number">1</span>)</span><br><span class="line">        swap(ss, i, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">ss, i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        t = ss[i]</span><br><span class="line">        ss[i] = ss[j]</span><br><span class="line">        ss[j] = t</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permutation(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;abc&#x27;, &#x27;acb&#x27;, &#x27;bac&#x27;, &#x27;bca&#x27;, &#x27;cab&#x27;, &#x27;cba&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Permutation2</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;回溯&quot;&quot;&quot;</span></span><br><span class="line">    space = <span class="built_in">list</span>(s)</span><br><span class="line">    res = []</span><br><span class="line">    PermutationCore(<span class="string">&quot;&quot;</span>, space, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PermutationCore</span>(<span class="params">cur_str, space, res</span>): </span><br><span class="line">    <span class="keyword">for</span> one_char <span class="keyword">in</span> space:</span><br><span class="line">        next_space = [one <span class="keyword">for</span> one <span class="keyword">in</span> space <span class="keyword">if</span> one != one_char ]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(next_space) == <span class="number">0</span>:</span><br><span class="line">            res.append(cur_str + one_char)</span><br><span class="line">        PermutationCore(cur_str + one_char, next_space, res)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permutation2(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;abc&#x27;, &#x27;acb&#x27;, &#x27;bac&#x27;, &#x27;bca&#x27;, &#x27;cab&#x27;, &#x27;cba&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="NO-39-数组中出现次数超过一半的数字"><a href="#NO-39-数组中出现次数超过一半的数字" class="headerlink" title="NO.39 数组中出现次数超过一半的数字"></a>NO.39 数组中出现次数超过一半的数字</h2><ul>
<li><strong>问题描述</strong>：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</li>
<li><strong>思路</strong>：在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，并把次数设为1。</li>
<li><strong>优点</strong>：先排序的时间复杂度是$O(nlogn)$；这种方法的时间复杂度是$O(n)$，不需要改变原数组，额外的空间复杂度也是常数。<br>-<strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MoreThanHalfNum1</span>(<span class="params">numbers, length</span>):</span><br><span class="line">    result = numbers[<span class="number">0</span>]</span><br><span class="line">    times = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        <span class="keyword">if</span> times == <span class="number">0</span>:</span><br><span class="line">            result = numbers[i]</span><br><span class="line">            times = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> numbers[i] == result:</span><br><span class="line">            times += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            times -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">MoreThanHalfNum1(l, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路</strong>：先做一个转化：数组中有一个数字出现的次数超过一半，那么排序之后，位于中间的数字，一定是这个数字，也就是<strong>中位数</strong>。考虑到快排的<strong>partition</strong>会返回调整完顺序后pivot的下标，如果返回的下标等于$n&#x2F;2$，则说明是中位数就是这个数</li>
<li><strong>优点</strong>：利用了<strong>partition</strong>函数的一个特性：返回的piviot的下标和最终排序好的数组中的下标是一样的。所以如果partion返回$n&#x2F;2$，那么这个数一定是中位数。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">data, s, e</span>):</span><br><span class="line">    <span class="keyword">if</span> s &gt;= e:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    small = s - <span class="number">1</span></span><br><span class="line">    pivot_index = e</span><br><span class="line">    pivot_value = data[pivot_index]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, e):</span><br><span class="line">        <span class="keyword">if</span> data[i] &lt; pivot_value:</span><br><span class="line">            small += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> small != i:</span><br><span class="line">                data[small], data[i] = data[i], data[small]</span><br><span class="line">    small += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> small != e:</span><br><span class="line">        data[small], data[e] = data[e], data[small]</span><br><span class="line">    <span class="keyword">return</span> small</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(partition(data, <span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">[2, 1, 3, 4, 9, 5]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MoreThanHalfNum2</span>(<span class="params">numbers, length</span>):</span><br><span class="line">    mid = length // <span class="number">2</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    e = length - <span class="number">1</span></span><br><span class="line">    index = partrition(numbers, s, e)</span><br><span class="line">    <span class="keyword">while</span> index != mid:</span><br><span class="line">        <span class="keyword">if</span> index &gt; mid:</span><br><span class="line">            e = index - <span class="number">1</span></span><br><span class="line">            index = partition(numbers, s, e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = index + <span class="number">1</span></span><br><span class="line">            index = partition(numbers, s, e)</span><br><span class="line">    res = numbers[mid]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">MoreThanHalfNum2(l, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="NO-40-最小的k个数"><a href="#NO-40-最小的k个数" class="headerlink" title="NO.40 最小的k个数"></a>NO.40 最小的k个数</h2><ul>
<li><strong>问题描述</strong>：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</li>
<li><strong>思路</strong>：类似上一题，使用<strong>partition</strong>函数，直到返回的下标是k为止。</li>
<li><strong>优点</strong>：如果先排序，时间复杂度是$nlog(n)$，这里时间复杂度是$O(n)$。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeastNumbers1</span>(<span class="params">data, k</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= k:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    e = <span class="built_in">len</span>(data) - <span class="number">1</span></span><br><span class="line">    index = partition(data, s, e)</span><br><span class="line">    <span class="keyword">while</span> index != k - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt; k - <span class="number">1</span>:</span><br><span class="line">            e = index - <span class="number">1</span></span><br><span class="line">            index = partition(data, s, e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = index + <span class="number">1</span></span><br><span class="line">            index = partition(data, s, e)</span><br><span class="line">    <span class="keyword">return</span> data[:k]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">getLeastNumbers1(data, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路</strong>：使用一个数据结构（这里选择大顶堆），在遍历数据的时候保留最小的k个数。每次要获取k个数中最大的数，所以用大顶堆。大顶堆在插入和删除数据时的时间复杂度都是$O(logk)$。</li>
<li><strong>优点</strong>：更能应对海量数据的情况。</li>
<li><strong>时间复杂度</strong>：$O(nlogk)$</li>
</ul>
<p>python自带<code>heapq</code>支持小顶堆。</p>
<p>核心文档，摘自<a href="https://docs.python.org/3.6/library/heapq.html">https://docs.python.org/3.6/library/heapq.html</a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">To create a heap,</span><br><span class="line">use a list initialized to [], or you can transform a populated list into a heap</span><br><span class="line">via function heapify().</span><br><span class="line"></span><br><span class="line">The following functions are provided:</span><br><span class="line">heapq.heappush(heap, item)</span><br><span class="line">Push the value item onto the heap, maintaining the</span><br><span class="line">heap invariant.</span><br><span class="line"></span><br><span class="line">heapq.heappop(heap)</span><br><span class="line">Pop and return the smallest item from the</span><br><span class="line">heap, maintaining the heap invariant. If the heap is empty, IndexError is</span><br><span class="line">raised. To access the smallest item without popping it, use heap[0].</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解法2</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLeastNumbers2</span>(<span class="params">data, k</span>):</span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(h) &lt; k:</span><br><span class="line">            <span class="comment"># heapq默认是小顶堆的操作，将元素加上符号使其变成大顶堆。</span></span><br><span class="line">            heapq.heappush(h, -one)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v = heapq.heappop(h)</span><br><span class="line">            <span class="keyword">if</span> -one &gt; v:</span><br><span class="line">                heapq.heappush(h, -one)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(h, v)</span><br><span class="line">    <span class="keyword">return</span> [-one <span class="keyword">for</span> one <span class="keyword">in</span> h]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">getLeastNumbers2(data, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<h2 id="NO-41-数据流中的中位数"><a href="#NO-41-数据流中的中位数" class="headerlink" title="NO.41 数据流中的中位数"></a>NO.41 数据流中的中位数</h2><ul>
<li><strong>问题描述</strong>：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</li>
<li><strong>思路</strong>：数据流意味着需要考虑新的数据进入时，数据结构的<strong>插入</strong>的操作。</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>插入的时间复杂度</th>
<th>得到中位数的时间复杂度</th>
<th>得到中位数的思路</th>
</tr>
</thead>
<tbody><tr>
<td>没有排序的数组</td>
<td>$O(1)$</td>
<td>$O(n)$</td>
<td>参考no.39题，使用partition</td>
</tr>
<tr>
<td>排序的数组</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>直接通过下标获取</td>
</tr>
<tr>
<td>排序的链表</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>定义指向中位数的指针</td>
</tr>
<tr>
<td>二叉搜索树</td>
<td>平均$O(logn)$，最差$O(n)$</td>
<td>平均$O(logn)$，最差$O(n)$</td>
<td>节点中添加一个表示子树节点个数的字段</td>
</tr>
<tr>
<td>平衡二叉搜索树AVL</td>
<td>平均$O(logn)$</td>
<td>$O(1)$</td>
<td>将平衡因子从左右子树的高度差修改成左右子树的节点数目差</td>
</tr>
<tr>
<td>最大堆</td>
<td>$O(logn)$</td>
<td>$O(1)$</td>
<td>用一个最大堆和一个最小堆实现</td>
</tr>
</tbody></table>
<p><strong>详细</strong>：保证数据平均分配到两个堆中，二者数目差不能超过1。在总数是偶数时，插入最小堆，否则插入最大堆。另外需要保证最大堆中的所有数据都<strong>小于</strong>最小堆中的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.max_heap = []</span><br><span class="line">        <span class="variable language_">self</span>.min_heap = []   </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="comment"># 总数是偶数时，插入最小堆</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) + <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap)) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.min_heap, val)</span><br><span class="line">            <span class="variable language_">self</span>.check()</span><br><span class="line">        <span class="comment"># 否则插入最大堆</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.max_heap, -val)</span><br><span class="line">            <span class="variable language_">self</span>.check()</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果最小堆的最小值小于最大堆的最大值，则需要交换二者</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="variable language_">self</span>.min_heap[<span class="number">0</span>] &lt; -<span class="variable language_">self</span>.max_heap[<span class="number">0</span>]:</span><br><span class="line">            min_one = heapq.heappop(<span class="variable language_">self</span>.min_heap)</span><br><span class="line">            max_one = -heapq.heappop(<span class="variable language_">self</span>.max_heap)</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.min_heap, max_one)</span><br><span class="line">            heapq.heappush(<span class="variable language_">self</span>.max_heap, -min_one)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_median</span>(<span class="params">self</span>):</span><br><span class="line">        size = <span class="built_in">len</span>(<span class="variable language_">self</span>.max_heap) + <span class="built_in">len</span>(<span class="variable language_">self</span>.min_heap)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No numbers are available!&quot;</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        median = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> size % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            median = <span class="variable language_">self</span>.min_heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            median = (<span class="variable language_">self</span>.min_heap[<span class="number">0</span>] + (-<span class="variable language_">self</span>.max_heap[<span class="number">0</span>])) / <span class="number">2</span></span><br><span class="line"><span class="comment">#         print(self.min_heap, self.max_heap)</span></span><br><span class="line">        <span class="keyword">return</span> median</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">da = DynamicArray()</span><br><span class="line">data = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> i, one <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    da.insert(one)</span><br><span class="line">    <span class="built_in">print</span>(data[:i+<span class="number">1</span>], da.get_median())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[3] 3</span><br><span class="line">[3, 2] 2.5</span><br><span class="line">[3, 2, 1] 2</span><br><span class="line">[3, 2, 1, 5] 2.5</span><br><span class="line">[3, 2, 1, 5, 7] 3</span><br><span class="line">[3, 2, 1, 5, 7, 8] 4.0</span><br><span class="line">[3, 2, 1, 5, 7, 8, 9] 5</span><br><span class="line">[3, 2, 1, 5, 7, 8, 9, 10] 6.0</span><br></pre></td></tr></table></figure>

<h2 id="NO-42-连续子数组的最大和"><a href="#NO-42-连续子数组的最大和" class="headerlink" title="NO.42 连续子数组的最大和"></a>NO.42 连续子数组的最大和</h2><ul>
<li><strong>问题描述</strong>：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O（n）。</li>
<li><strong>思路</strong>：$$f(i) &#x3D; \left{\begin{matrix}<br>Data[i] \qquad i&#x3D;0 或者 f(i-1) \leq 0 \<br>f(i-1)+Data[i] \qquad i \neq 0 或者 f(i-1) \gt 0<br>\end{matrix}\right.$$<br>其中$f(i)$代表以第i个数字结尾的子数组的最大和。最终结果即$\underset{i}{max}[f(i)]$。</li>
<li><strong>优点</strong>：时间复杂度低。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findGreatestSumOfSubArray</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Data is empty!!!&quot;</span>)</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>]</span><br><span class="line">    max_sum_end_with_i = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))]</span><br><span class="line">    max_sum_end_with_i[<span class="number">0</span>] = data[<span class="number">0</span>] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> max_sum_end_with_i[i - <span class="number">1</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">            max_sum_end_with_i[i] = data[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_sum_end_with_i[i] = data[i] + max_sum_end_with_i[i-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(max_sum_end_with_i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(max_sum_end_with_i)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_data = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(findGreatestSumOfSubArray(test_data))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, -1, 3, 13, 9, 16, 18, 13]</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<h2 id="NO-43-从1到n整数中1出现的次数"><a href="#NO-43-从1到n整数中1出现的次数" class="headerlink" title="NO.43 从1到n整数中1出现的次数"></a>NO.43 从1到n整数中1出现的次数</h2><ul>
<li><strong>问题描述</strong>：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1<br>的数字有1，10，11和12，1一共出现了5次。</li>
<li><strong>思路</strong>：简单的可以计算每一个数中1出现的个数，再累加，这种方案的时间复杂度是$nlog(n)$。较优方案：从最高位开始统计1的个数，再递归。<strong>具体</strong>：将这个问题分解成3部分：1.最高位中1出现的次数；2.除了最高位以后，其他位中1出现的个数。这部分又分成两部分：2.1.最高位是小于当前最高位的时候，其他位数中，1的个数（排列组合）；2.2.最高位是当前最高位时，其他位数中1的个数（递归）。<strong>举例</strong>：求1到21345中1出现的次数。1.最高位中1出现了10000次；2.最高位是0或者1时，其他位中1出现的次数。选择后四位中其中一位是1，其他三位任意，是$2×(5-1)×10^3&#x3D;1000$；3.20000<del>21345除第一位之外的数位中1的数目，等同于1</del>1345中1的数目，使用递归。</li>
<li><strong>优点</strong>：递归的次数和位数相同，时间复杂度是$log(n)$。</li>
<li><strong>时间复杂度</strong>：$log(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numberOf1Between1AndN</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> numberOf1(<span class="built_in">str</span>(n))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numberOf1</span>(<span class="params">str_n</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(str_n) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> str_n[<span class="number">0</span>].isdigit():</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    first = <span class="built_in">int</span>(str_n[<span class="number">0</span>])</span><br><span class="line">    l = <span class="built_in">len</span>(str_n)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> <span class="keyword">and</span> first == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> <span class="keyword">and</span> first &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 假设str_n是&quot;21345&quot;</span></span><br><span class="line">    <span class="comment"># 1.num_first_digit是数字10000~19999的第一位中的1的数目</span></span><br><span class="line">    num_first_digit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> first &gt; <span class="number">1</span>:</span><br><span class="line">        num_first_digit = powerBase10(l - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> first == <span class="number">1</span>:</span><br><span class="line">        num_first_digit = <span class="built_in">int</span>(str_n[<span class="number">1</span>:]) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 2.num_other_digit是00000~19999除第一位之外的数位中的1的数目，使用排列组合</span></span><br><span class="line"><span class="comment">#     print(first, (l - 1), powerBase10(l - 2))</span></span><br><span class="line">    num_other_digit = first * (l - <span class="number">1</span>) * powerBase10(l - <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 3.num_recursive是20000~21345除第一位之外的数位中1的数目，等同于1~1345中1的数目，使用递归</span></span><br><span class="line">    numRecursive = numberOf1(str_n[<span class="number">1</span>:])</span><br><span class="line"><span class="comment">#     print(num_first_digit, num_other_digit, numRecursive)</span></span><br><span class="line">    <span class="keyword">return</span> num_first_digit + num_other_digit + numRecursive</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">powerBase10</span>(<span class="params">n</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        res *= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numberOf1Between1AndN(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="NO-44-数字序列中某一位的数字"><a href="#NO-44-数字序列中某一位的数字" class="headerlink" title="NO.44 数字序列中某一位的数字"></a>NO.44 数字序列中某一位的数字</h2><ul>
<li><strong>问题描述</strong>：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</li>
<li><strong>思路</strong>：简单思路：从1开始构建字符串，设置一个简单变量k保存当前的长度，直到k&#x3D;&#x3D;n，停止遍历。计算m位数最多能到达的边界，确定第n位对应的数字是多少位，再确定n是什么数字。</li>
<li><strong>优点</strong>：时间复杂度是$log(n)$。</li>
<li><strong>时间复杂度</strong>：$log(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">digitAtIndex</span>(<span class="params">index</span>):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    digits = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        numbers = countOfIntegers(digits)</span><br><span class="line">        <span class="keyword">if</span> index &lt; numbers * digits:</span><br><span class="line">            <span class="keyword">return</span> digitAtIndexWithMDigits(index, digits)</span><br><span class="line">        index -= numbers * digits</span><br><span class="line">        digits += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countOfIntegers</span>(<span class="params">digits</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;输入1，返回0-9的个数10；输入2，返回10-99的个数90；输入3，返回100-999的个数900&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> digits == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    count = <span class="number">9</span> * <span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digitAtIndexWithMDigits</span>(<span class="params">index, digits</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在直到index指向的数是m位数的前提下，返回index指向的数字&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 找到index指向的这个数是属于哪个整数</span></span><br><span class="line">    number = beginNumber(digits) + index // digits</span><br><span class="line">    indexFromRight = digits - index % digits</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, indexFromRight):</span><br><span class="line">        number = number // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">beginNumber</span>(<span class="params">digits</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回m位数的第一个数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> digits == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(digitAtIndex(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(digitAtIndex(<span class="number">13</span>))</span><br><span class="line"><span class="built_in">print</span>(digitAtIndex(<span class="number">19</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="NO-45-把数组排成最小的数"><a href="#NO-45-把数组排成最小的数" class="headerlink" title="NO.45 把数组排成最小的数"></a>NO.45 把数组排成最小的数</h2><ul>
<li><strong>问题描述</strong>：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</li>
<li><strong>思路</strong>：这道题可以看做是一种特殊的<strong>排序</strong>，核心在于如何实现<strong>比较</strong>。给定数字m和n，比较函数需要确定m和n谁排在前面。根据题目要求，如果$mn&lt;nm$，则应该是m排在n前面，也就是说m“小于”n。</li>
<li><strong>优点</strong>：时间复杂度跟排序一样。</li>
<li><strong>时间复杂度</strong>：采样快排，则为$nlog(n)$。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printMinNumber</span>(<span class="params">numbers</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    sorted_numbers = <span class="built_in">sorted</span>(<span class="built_in">map</span>(my_int, numbers))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, sorted_numbers))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_int</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Refer to https://softwareengineering.stackexchange.com/questions/151069/sorting-using-a-custom-definition-of-and-in-python&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">n, m</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(n) + <span class="built_in">str</span>(m) &lt; <span class="built_in">str</span>(m) + <span class="built_in">str</span>(n)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># def compare_ints(n, m):</span></span><br><span class="line"><span class="comment">#     return str(n) + str(m) &lt; str(m) + str(n)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMinNumber([<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;321323&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="NO-46-把数字翻译成字符串"><a href="#NO-46-把数字翻译成字符串" class="headerlink" title="NO.46 把数字翻译成字符串"></a>NO.46 把数字翻译成字符串</h2><ul>
<li><strong>问题描述</strong>：给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”…25翻译成“z”。一个数字有多种翻译可能，例如12258一共有5种，分别是bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</li>
<li><strong>思路1</strong>：使用递归：定义$f(i)$表示从第i位数字开始的不同翻译的数目，$g(i,<br>i+1)$代表第i位和第i+1位两位数字拼在一起是否在10~25的范围内，那么$f(i) &#x3D; f(i+1)+g(i, i+1) × f(i+2)$。</li>
<li><strong>特点</strong>：思路清晰，但式子中的$f(i+1)$和$f(i+2)$明显有重复计算的部分。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getTranslationCount1</span>(<span class="params">num_s</span>):</span><br><span class="line"><span class="comment">#     print(num_s)</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(num_s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(num_s) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num_s[<span class="number">0</span>] == <span class="string">&quot;1&quot;</span> <span class="keyword">or</span> (num_s[<span class="number">0</span>] == <span class="string">&quot;2&quot;</span> <span class="keyword">and</span> <span class="built_in">int</span>(num_s[<span class="number">1</span>]) &lt; <span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num_s) &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> getTranslationCount1(num_s[<span class="number">1</span>:]) + getTranslationCount1(num_s[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> getTranslationCount1(num_s[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个测试样例：<ul>
<li>2 2 -&gt; cc</li>
<li>22 -&gt; w</li>
</ul>
</li>
<li>第二个测试样例：<ul>
<li>1 2 2 5 8 -&gt; bccfi</li>
</ul>
</li>
<li>1 22 5 8 -&gt; bwfi<ul>
<li>1 2 25 8 -&gt; bczi</li>
<li>12 2 5 8 -&gt; mcfi</li>
<li>12 25 8 -&gt; mzi</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(getTranslationCount1(<span class="string">&quot;22&quot;</span>)) </span><br><span class="line"><span class="built_in">print</span>(getTranslationCount1(<span class="string">&quot;12258&quot;</span>)) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路2</strong>：考虑从最小的问题自下而上地解决问题，类似动态规划思路。</li>
<li><strong>优点</strong>：避免思路1中大量的重复计算。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getTranslationCount2</span>(<span class="params">num_s</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(num_s)</span><br><span class="line">    counts = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; l - <span class="number">1</span>:</span><br><span class="line">            count = counts[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; l - <span class="number">1</span>:</span><br><span class="line">            digit_1 = <span class="built_in">int</span>(num_s[i])</span><br><span class="line">            digit_2 = <span class="built_in">int</span>(num_s[i+<span class="number">1</span>])</span><br><span class="line">            converted = digit_1 * <span class="number">10</span> + digit_2</span><br><span class="line">            <span class="keyword">if</span> converted &gt;= <span class="number">10</span> <span class="keyword">and</span> converted &lt;= <span class="number">25</span>:</span><br><span class="line">                <span class="keyword">if</span> i &lt; l - <span class="number">2</span>:</span><br><span class="line">                    count += counts[i+<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        counts[i] = count</span><br><span class="line">    <span class="keyword">return</span> counts[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(getTranslationCount2(<span class="string">&quot;22&quot;</span>)) </span><br><span class="line"><span class="built_in">print</span>(getTranslationCount2(<span class="string">&quot;12258&quot;</span>)) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="NO-47-礼物的最大价值"><a href="#NO-47-礼物的最大价值" class="headerlink" title="NO.47 礼物的最大价值"></a>NO.47 礼物的最大价值</h2><ul>
<li><strong>问题描述</strong>：在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格，知道到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿多少价值的礼物？</li>
<li><strong>思路</strong>：这是一个典型的用<strong>动态规划</strong>解决的问题。定义$f(i,j)$表示到达坐标$(i,j)$的格子能拿到的礼物的最大值。很明显：$f(i,j) &#x3D; max(f(i,j-1), f(i-1, j)) + gift[i,j]$</li>
<li><strong>优点</strong>：思路清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getMaxValue1</span>(<span class="params">values, rows, cols</span>):</span><br><span class="line">    <span class="keyword">if</span> values <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> rows &lt;= <span class="number">0</span> <span class="keyword">or</span> cols &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    max_values = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            up = <span class="number">0</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                up = max_values[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                left = max_values[i][j-<span class="number">1</span>]</span><br><span class="line">            max_values[i][j] = values[i][j] + <span class="built_in">max</span>(up, left)</span><br><span class="line">    <span class="keyword">return</span> max_values[rows-<span class="number">1</span>][cols-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">values = [[<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>], </span><br><span class="line">          [<span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>],</span><br><span class="line">          [<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>],</span><br><span class="line">          [<span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">getMaxValue1(values, <span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路</strong>：继续优化：每次计算$(i,j)$时只依赖$(i-1,j)$和$(i, j-1)$两个格子，因此第$i-2$行和更上面的所有格子的最优结果无需保存。因此可以用一个<strong>一维数组</strong>来取代二维数组。在判断位置$(i,j)$时，一维数组前j个数字分别是$f(i,0),f(i,1),…,f(i, j-1)$（当前行已经更新的最佳结果），后面的数字是$f(i-1, j), f(i-1, j+1), …, f(i-1,cols-1)$（上一行的最佳结果）。</li>
<li><strong>优点</strong>：空间复杂度相对减少。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getMaxValue2</span>(<span class="params">values, rows, cols</span>):</span><br><span class="line">    <span class="keyword">if</span> values <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> rows &lt;= <span class="number">0</span> <span class="keyword">or</span> cols &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    max_values = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            up = <span class="number">0</span></span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                up = max_values[j]</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                left = max_values[j-<span class="number">1</span>]</span><br><span class="line">            max_values[j] = values[i][j] + <span class="built_in">max</span>(up, left)</span><br><span class="line">    <span class="keyword">return</span> max_values[cols-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">values = [[<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>], </span><br><span class="line">          [<span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>],</span><br><span class="line">          [<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>],</span><br><span class="line">          [<span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">getMaxValue2(values, <span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53</span><br></pre></td></tr></table></figure>

<h2 id="NO-48-最长不含重复字符的子字符串"><a href="#NO-48-最长不含重复字符的子字符串" class="headerlink" title="NO.48 最长不含重复字符的子字符串"></a>NO.48 最长不含重复字符的子字符串</h2><ul>
<li><strong>问题描述</strong>：请从字符串中找出一个最长的不包含重复字符串的子字符串，计算该最长子字符串的长度。假设字符串中只包含‘a’~‘z’的字符。例如，在字符串“arabcacfr”中，最长的不含重复字符的子字符串是“acfr”，长度是4。</li>
<li><strong>思路</strong>：动态规划，定义函数$f(i)$表示第$i$个字符为结尾的不包含重复子字符串的最长长度。如果第$i$个字符之前没有出现过，那么$f(i) &#x3D; f(i-1) + 1$。如果出现过，则分为两种情况：记录$d$为第$i$个字符和它上次出现的位置之间的距离，如果$d\leq f(i-1)$，则$f(i)&#x3D;d$；反之，仍有$f(i) &#x3D; f(i-1) + 1$。</li>
<li><strong>优点</strong>：时间复杂度是$O(n)$，暴力法是$O(n^3)$。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestSubstringWithoutDuplication</span>(<span class="params">string</span>):</span><br><span class="line">    cur_len = <span class="number">0</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    position = [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string)):</span><br><span class="line">        prev_index = position[<span class="built_in">ord</span>(string[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)]</span><br><span class="line">        <span class="keyword">if</span> prev_index &lt; <span class="number">0</span> <span class="keyword">or</span> i - prev_index &gt; cur_len:</span><br><span class="line">            cur_len += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">            cur_len = i - prev_index</span><br><span class="line">        position[<span class="built_in">ord</span>(string[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] = i</span><br><span class="line">    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">        max_len = cur_len</span><br><span class="line">    <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">longestSubstringWithoutDuplication(<span class="string">&quot;arabcacfr&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="NO-49-丑数"><a href="#NO-49-丑数" class="headerlink" title="NO.49 丑数"></a>NO.49 丑数</h2><ul>
<li><strong>问题描述</strong>：把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。</li>
<li><strong>思路1</strong>：逐个判断每个整数是不是丑数。</li>
<li><strong>优点</strong>：直观但不够高效。需要判断每个不是丑数的数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isUgly</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">while</span> number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        number /= <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> number % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        number /= <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> number % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        number /= <span class="number">5</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> number == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUglyNumber1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#     ugly_numbers = []  # 调试用</span></span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    uglyFound = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> uglyFound &lt; n:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isUgly(number):</span><br><span class="line">            uglyFound += <span class="number">1</span></span><br><span class="line"><span class="comment">#             ugly_numbers.append(number)</span></span><br><span class="line"><span class="comment">#     print(ugly_numbers)</span></span><br><span class="line">    <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isUgly(<span class="number">40</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">s = time.time()</span><br><span class="line"><span class="built_in">print</span>(getUglyNumber1(<span class="number">500</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Time cost: &quot;</span>, time.time() - s)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">937500</span><br><span class="line">Time cost:  0.5277576446533203</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路2</strong>：创建数组保存已经找到的丑数，用空间换时间。假设已经有若干个排好序的丑数数组，并且最大的丑数记做$M$，下一个丑数必然是前面其中某一个丑数乘以2、3或者5的结果。第一个乘以2大于$M$的记为$M_2$，第一个乘以3大于$M$的记为$M_3$，第一个乘以5大于$M$的记为$M_5$。</li>
<li><strong>优点</strong>：不用计算不是丑数的数，用空间换时间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getUglyNumber2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ugly_numbers = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    ugly_numbers[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    next_ugly_index = <span class="number">1</span></span><br><span class="line">    mutiply_2_index = <span class="number">0</span></span><br><span class="line">    mutiply_3_index = <span class="number">0</span></span><br><span class="line">    mutiply_5_index = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> next_ugly_index &lt; n:</span><br><span class="line">        min_one = <span class="built_in">min</span>(ugly_numbers[mutiply_2_index] * <span class="number">2</span>, ugly_numbers[mutiply_3_index] * <span class="number">3</span>, ugly_numbers[mutiply_5_index] * <span class="number">5</span>)</span><br><span class="line">        ugly_numbers[next_ugly_index] = min_one</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ugly_numbers[mutiply_2_index] * <span class="number">2</span> &lt;= min_one:</span><br><span class="line">            mutiply_2_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ugly_numbers[mutiply_3_index] * <span class="number">3</span> &lt;= min_one:</span><br><span class="line">            mutiply_3_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ugly_numbers[mutiply_5_index] * <span class="number">5</span> &lt;= min_one:</span><br><span class="line">            mutiply_5_index += <span class="number">1</span></span><br><span class="line">        next_ugly_index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#     print(ugly_numbers)</span></span><br><span class="line">    <span class="keyword">return</span> ugly_numbers[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">s = time.time()</span><br><span class="line"><span class="built_in">print</span>(getUglyNumber2(<span class="number">500</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Time cost: &quot;</span>, time.time() - s)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">937500</span><br><span class="line">Time cost:  0.0006611347198486328</span><br></pre></td></tr></table></figure>

<p>可以明显看到思路2的速度快很多，而且n越大，时间差距越明显。</p>
<h2 id="NO-50-第一个只出现一次的字符"><a href="#NO-50-第一个只出现一次的字符" class="headerlink" title="NO.50 第一个只出现一次的字符"></a>NO.50 第一个只出现一次的字符</h2><ul>
<li><strong>问题描述</strong>：在字符串中找出第一个只出现一次的字符。如输入“abaccdeff”，则输出‘b’。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-51-数组中的逆序对"><a href="#NO-51-数组中的逆序对" class="headerlink" title="NO.51 数组中的逆序对"></a>NO.51 数组中的逆序对</h2><ul>
<li><strong>问题描述</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。即输出<code>P%1000000007</code>。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-52-两个链表的第一个公共节点"><a href="#NO-52-两个链表的第一个公共节点" class="headerlink" title="NO.52 两个链表的第一个公共节点"></a>NO.52 两个链表的第一个公共节点</h2><ul>
<li><strong>问题描述</strong>：输入两个链表，找出它们的第一个公共结点。</li>
<li><strong>思路</strong>：遍历两个链表，确定长度m和n，假设m&gt;n，先走m-n步，再一起走，直到碰头。</li>
<li><strong>优点</strong>：时间复杂度低。</li>
<li><strong>时间复杂度</strong>：$O(m+n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findFirstCommonNode</span>(<span class="params">head1, head2</span>):</span><br><span class="line">    l1 = getListLength(head1)</span><br><span class="line">    l2 = getListLength(head2)</span><br><span class="line">    head_long = head1 <span class="keyword">if</span> l1 &gt; l2 <span class="keyword">else</span> head2</span><br><span class="line">    head_short = head2 <span class="keyword">if</span> l1 &gt; l2 <span class="keyword">else</span> head1</span><br><span class="line">    l_diff = l1 - l2 <span class="keyword">if</span> l1 &gt; l2 <span class="keyword">else</span> l2 - l1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l_diff):</span><br><span class="line">        head_long = head_long.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> head_long <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head_short <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head_long != head_short:</span><br><span class="line">        head_long = head_long.<span class="built_in">next</span></span><br><span class="line">        head_short = head_short.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">    firstCommonNode = head_long</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> firstCommonNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getListLength</span>(<span class="params">head</span>):</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line">n5 = ListNode(<span class="number">5</span>)</span><br><span class="line">n6 = ListNode(<span class="number">6</span>)</span><br><span class="line">n7 = ListNode(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n4.<span class="built_in">next</span> = n5</span><br><span class="line">n3.<span class="built_in">next</span> = n6</span><br><span class="line">n5.<span class="built_in">next</span> = n6</span><br><span class="line">n6.<span class="built_in">next</span> = n7</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(findFirstCommonNode(n1, n4).val)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="NO-53-在排序数组中查找数字"><a href="#NO-53-在排序数组中查找数字" class="headerlink" title="NO.53 在排序数组中查找数字"></a>NO.53 在排序数组中查找数字</h2><ul>
<li><strong>问题描述</strong>：统计一个数字在排序数组中出现的次数。如，输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-54-二叉搜索树的第k大节点"><a href="#NO-54-二叉搜索树的第k大节点" class="headerlink" title="NO.54 二叉搜索树的第k大节点"></a>NO.54 二叉搜索树的第k大节点</h2><ul>
<li><strong>问题描述</strong>：给定一颗二叉搜索树，请找出其中的第k大的结点。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-55-二叉树的深度"><a href="#NO-55-二叉树的深度" class="headerlink" title="NO.55 二叉树的深度"></a>NO.55 二叉树的深度</h2><ul>
<li><strong>问题描述</strong>：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</li>
<li><strong>思路</strong>：递归：一棵树的长度 &#x3D; 1 (根节点) + max(左子树长度, 右子树长度)</li>
<li><strong>优点</strong>：简单清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">treeDepth</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n_left = treeDepth(root.left)</span><br><span class="line">    n_right = treeDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> n_left + <span class="number">1</span> <span class="keyword">if</span> n_left &gt; n_right <span class="keyword">else</span> n_right + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(treeDepth(n1))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 6 10 5 7 9 11</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="相关：平衡二叉树"><a href="#相关：平衡二叉树" class="headerlink" title="相关：平衡二叉树"></a>相关：平衡二叉树</h3><ul>
<li><strong>问题描述</strong>：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中的任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</li>
<li><strong>思路1</strong>：递归：使用上面的求深度函数，对每个节点的左右子树检查。</li>
<li><strong>优点</strong>：思路简单，但时间复杂度较高。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isBalanced1</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    n_left = treeDepth(root.left)</span><br><span class="line">    n_right = treeDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> n_left - n_right &lt;= <span class="number">1</span> <span class="keyword">and</span> n_left - n_right &gt;= -<span class="number">1</span> <span class="keyword">and</span> isBalanced1(root.left) <span class="keyword">and</span> isBalanced1(root.right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"></span><br><span class="line">isBalanced1(n1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8 6 10 5 7 9 11</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>思路2</strong>：使用<strong>后续遍历</strong>，“左右根”的遍历方式可以确保在遍历到一个节点时，其左右子树都是遍历过的。这样只需在遍历的时候记录下当前检查节点的深度并返回即可。</li>
<li><strong>优点</strong>：只用遍历一次。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isBalancedCore2</span>(<span class="params">root, depth_s</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        depth_s[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    left_ds = [<span class="number">0</span>]</span><br><span class="line">    right_ds = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> isBalancedCore2(root.left, left_ds) <span class="keyword">and</span> isBalancedCore2(root.right, right_ds):</span><br><span class="line">        diff = left_ds[<span class="number">0</span>] - right_ds[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> diff &lt;= <span class="number">1</span> <span class="keyword">and</span> diff &gt;= -<span class="number">1</span>:</span><br><span class="line">            depth_s[<span class="number">0</span>] = <span class="number">1</span> + left_ds[<span class="number">0</span>] <span class="keyword">if</span> left_ds[<span class="number">0</span>] &gt; right_ds[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">1</span> + right_ds[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isBalanced2</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">return</span> isBalancedCore2(root, [<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n1 = TreeNode(<span class="number">8</span>)</span><br><span class="line">n2 = TreeNode(<span class="number">6</span>)</span><br><span class="line">n3 = TreeNode(<span class="number">10</span>)</span><br><span class="line">n4 = TreeNode(<span class="number">5</span>)</span><br><span class="line">n5 = TreeNode(<span class="number">7</span>)</span><br><span class="line">n6 = TreeNode(<span class="number">9</span>)</span><br><span class="line">n7 = TreeNode(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br><span class="line">n3.left = n6</span><br><span class="line">n3.right = n7</span><br><span class="line"></span><br><span class="line">print_tree(n1)</span><br><span class="line"></span><br><span class="line">isBalanced2(n1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8 6 10 5 7 9 11</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="NO-56-数组中数字出现的次数"><a href="#NO-56-数组中数字出现的次数" class="headerlink" title="NO.56 数组中数字出现的次数"></a>NO.56 数组中数字出现的次数</h2><ul>
<li><strong>问题描述</strong>：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度$O(n)$，空间复杂度$O(1)$。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-57-和为s的数字"><a href="#NO-57-和为s的数字" class="headerlink" title="NO.57 和为s的数字"></a>NO.57 和为s的数字</h2><ul>
<li><strong>问题描述</strong>：输入一个递增排序的数组和一个数字，在数组中查找两个数，使得他们的和正好是s，如果有多对数字的和等于s，则输出任意一对即可。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-58-翻转字符串"><a href="#NO-58-翻转字符串" class="headerlink" title="NO.58 翻转字符串"></a>NO.58 翻转字符串</h2><ul>
<li><strong>问题描述</strong>：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。如，输入字符串“I am a student.”，则输出“student. a am I”。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-59-队列的最大值"><a href="#NO-59-队列的最大值" class="headerlink" title="NO.59 队列的最大值"></a>NO.59 队列的最大值</h2><ul>
<li><strong>问题描述</strong>：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组<code>&#123;2,3,4,2,6,2,5,1&#125;</code>及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为<code>&#123;4,4,6,6,6,5&#125;</code>；针对数组<code>&#123;2,3,4,2,6,2,5,1&#125;</code>的滑动窗口有以下6个： <code>&#123;[2,3,4],2,6,2,5,1&#125;</code>， <code>&#123;2,[3,4,2],6,2,5,1&#125;</code>，<code>&#123;2,3,[4,2,6],2,5,1&#125;</code>， <code>&#123;2,3,4,[2,6,2],5,1&#125;</code>， <code>&#123;2,3,4,2,[6,2,5],1&#125;</code>，<code>&#123;2,3,4,2,6,[2,5,1]&#125;</code>。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-60-n个骰子的点数"><a href="#NO-60-n个骰子的点数" class="headerlink" title="NO.60 n个骰子的点数"></a>NO.60 n个骰子的点数</h2><ul>
<li><strong>问题描述</strong>：把n个骰子扔在地上，所有骰子朝上的一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-61-扑克牌中的顺子"><a href="#NO-61-扑克牌中的顺子" class="headerlink" title="NO.61 扑克牌中的顺子"></a>NO.61 扑克牌中的顺子</h2><ul>
<li><strong>问题描述</strong>：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成任意数字。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-62-圆圈中最后剩下的数字"><a href="#NO-62-圆圈中最后剩下的数字" class="headerlink" title="NO.62 圆圈中最后剩下的数字"></a>NO.62 圆圈中最后剩下的数字</h2><ul>
<li><strong>问题描述</strong>：题目： 0、1…n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。如0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-63-股票的最大利润"><a href="#NO-63-股票的最大利润" class="headerlink" title="NO.63 股票的最大利润"></a>NO.63 股票的最大利润</h2><ul>
<li><strong>问题描述</strong>：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？例如，一只股票在某些时间节点的价格为{9,11,8,5,7,12,16,14}。如果我们能在价格为5的时候买入并在价格为16时卖出，则能获得最大的利润为11.</li>
<li><strong>思路</strong>：定义$diff(i)$代表卖出价是数组中第i个数字时，能获得的最大利润，那么最终的结果就是$\underset{i}{max} ;diff(i)$。而由于$diff(i)$可以在遍历时直接计算获得，所以不需要一个长度是n的数组保存所有的$diff(i)$，只需保存之前最大的$diff(i)$即可。</li>
<li><strong>优点</strong>：时间复杂度和空间复杂度都低。</li>
<li><strong>时间复杂度</strong>：$O(n)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDiff</span>(<span class="params">numbers</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    max_diff = -<span class="number">99999999</span></span><br><span class="line">    min_buy = numbers[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">        <span class="keyword">if</span> numbers[i] - min_buy &gt; max_diff:</span><br><span class="line">            max_diff = numbers[i] - min_buy</span><br><span class="line">        <span class="keyword">if</span> numbers[i] &lt; min_buy:</span><br><span class="line">            min_buy = numbers[i]</span><br><span class="line">    <span class="keyword">return</span> max_diff</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxDiff([<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">14</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>

<h2 id="NO-64-求1-2-…-n"><a href="#NO-64-求1-2-…-n" class="headerlink" title="NO.64 求1+2+…+n"></a>NO.64 求1+2+…+n</h2><ul>
<li><strong>问题描述</strong>：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-65-不用加减乘除做加法"><a href="#NO-65-不用加减乘除做加法" class="headerlink" title="NO.65 不用加减乘除做加法"></a>NO.65 不用加减乘除做加法</h2><ul>
<li><strong>问题描述</strong>：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、&#x2F;四则运算符号。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-66-构建乘积数组"><a href="#NO-66-构建乘积数组" class="headerlink" title="NO.66 构建乘积数组"></a>NO.66 构建乘积数组</h2><ul>
<li><strong>问题描述</strong>：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]&#x3D;A[0]A[1]…A[i-1]<em>A[i+1]…</em>A[n-1]。不能使用除法。</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-67-把字符串转换成整数"><a href="#NO-67-把字符串转换成整数" class="headerlink" title="NO.67 把字符串转换成整数"></a>NO.67 把字符串转换成整数</h2><ul>
<li><strong>问题描述</strong>：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。数值为0或者字符串不是一个合法的数值则返回0</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>
<h2 id="NO-68-树中两个结点的最低公共祖先"><a href="#NO-68-树中两个结点的最低公共祖先" class="headerlink" title="NO.68 树中两个结点的最低公共祖先"></a>NO.68 树中两个结点的最低公共祖先</h2><ul>
<li><strong>问题描述</strong>：输入两个树节点，求他们的最低公共祖先。<ul>
<li>二叉树（二叉搜索树）：二叉搜索树是排序的，如果当前节点大于两个节点的值，去左子树中寻找；如果当前节点小于两个节点的值，去右子树中寻找；如果当前节点位于两个节点值之间，则该节点就是要寻找的最低公共祖先。</li>
<li>普通树（存在指向父节点的指针）：从给定节点出发，由父节点指针回到到根结点，形成链表。从而将问题转化为求两个链表的第一个公共节点的问题。</li>
<li>普通树（不存在指向父节点的指针）：利用两个辅助链表通过递归遍历的方法找到两条到达给定节点的路径，寻找两个链表最后一个公共节点，就是最低公共祖先。</li>
</ul>
</li>
<li><strong>思路</strong>：</li>
<li><strong>优点</strong>：</li>
<li><strong>时间复杂度</strong>：</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/algrithom/book_learning_6/" rel="prev" title="六. Trees and Tree Algorithms">
                  <i class="fa fa-angle-left"></i> 六. Trees and Tree Algorithms
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/deep_learning_book/deep_learning_1/" rel="next" title="第一章：introduction">
                  第一章：introduction <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Javen Chen</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
